"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/openapi-fetch";
exports.ids = ["vendor-chunks/openapi-fetch"];
exports.modules = {

/***/ "(ssr)/./node_modules/openapi-fetch/dist/cjs/index.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/openapi-fetch/dist/cjs/index.cjs ***!
  \*******************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.js\nvar index_exports = {};\n__export(index_exports, {\n  createFinalURL: () => createFinalURL,\n  createPathBasedClient: () => createPathBasedClient,\n  createQuerySerializer: () => createQuerySerializer,\n  default: () => createClient,\n  defaultBodySerializer: () => defaultBodySerializer,\n  defaultPathSerializer: () => defaultPathSerializer,\n  mergeHeaders: () => mergeHeaders,\n  randomID: () => randomID,\n  removeTrailingSlash: () => removeTrailingSlash,\n  serializeArrayParam: () => serializeArrayParam,\n  serializeObjectParam: () => serializeObjectParam,\n  serializePrimitiveParam: () => serializePrimitiveParam,\n  wrapAsPathBasedClient: () => wrapAsPathBasedClient\n});\nmodule.exports = __toCommonJS(index_exports);\nvar PATH_PARAM_RE = /\\{[^{}]+\\}/g;\nvar supportsRequestInitExt = () => {\n  return typeof process === \"object\" && Number.parseInt(process?.versions?.node?.substring(0, 2)) >= 18 && process.versions.undici;\n};\nfunction randomID() {\n  return Math.random().toString(36).slice(2, 11);\n}\nfunction createClient(clientOptions) {\n  let {\n    baseUrl = \"\",\n    Request: CustomRequest = globalThis.Request,\n    fetch: baseFetch = globalThis.fetch,\n    querySerializer: globalQuerySerializer,\n    bodySerializer: globalBodySerializer,\n    headers: baseHeaders,\n    requestInitExt = void 0,\n    ...baseOptions\n  } = { ...clientOptions };\n  requestInitExt = supportsRequestInitExt() ? requestInitExt : void 0;\n  baseUrl = removeTrailingSlash(baseUrl);\n  const middlewares = [];\n  async function coreFetch(schemaPath, fetchOptions) {\n    const {\n      baseUrl: localBaseUrl,\n      fetch = baseFetch,\n      Request = CustomRequest,\n      headers,\n      params = {},\n      parseAs = \"json\",\n      querySerializer: requestQuerySerializer,\n      bodySerializer = globalBodySerializer ?? defaultBodySerializer,\n      body,\n      ...init\n    } = fetchOptions || {};\n    let finalBaseUrl = baseUrl;\n    if (localBaseUrl) {\n      finalBaseUrl = removeTrailingSlash(localBaseUrl) ?? baseUrl;\n    }\n    let querySerializer = typeof globalQuerySerializer === \"function\" ? globalQuerySerializer : createQuerySerializer(globalQuerySerializer);\n    if (requestQuerySerializer) {\n      querySerializer = typeof requestQuerySerializer === \"function\" ? requestQuerySerializer : createQuerySerializer({\n        ...typeof globalQuerySerializer === \"object\" ? globalQuerySerializer : {},\n        ...requestQuerySerializer\n      });\n    }\n    const serializedBody = body === void 0 ? void 0 : bodySerializer(\n      body,\n      // Note: we declare mergeHeaders() both here and below because it’s a bit of a chicken-or-egg situation:\n      // bodySerializer() needs all headers so we aren’t dropping ones set by the user, however,\n      // the result of this ALSO sets the lowest-priority content-type header. So we re-merge below,\n      // setting the content-type at the very beginning to be overwritten.\n      // Lastly, based on the way headers work, it’s not a simple “present-or-not” check becauase null intentionally un-sets headers.\n      mergeHeaders(baseHeaders, headers, params.header)\n    );\n    const finalHeaders = mergeHeaders(\n      // with no body, we should not to set Content-Type\n      serializedBody === void 0 || // if serialized body is FormData; browser will correctly set Content-Type & boundary expression\n      serializedBody instanceof FormData ? {} : {\n        \"Content-Type\": \"application/json\"\n      },\n      baseHeaders,\n      headers,\n      params.header\n    );\n    const requestInit = {\n      redirect: \"follow\",\n      ...baseOptions,\n      ...init,\n      body: serializedBody,\n      headers: finalHeaders\n    };\n    let id;\n    let options;\n    let request = new CustomRequest(\n      createFinalURL(schemaPath, { baseUrl: finalBaseUrl, params, querySerializer }),\n      requestInit\n    );\n    let response;\n    for (const key in init) {\n      if (!(key in request)) {\n        request[key] = init[key];\n      }\n    }\n    if (middlewares.length) {\n      id = randomID();\n      options = Object.freeze({\n        baseUrl: finalBaseUrl,\n        fetch,\n        parseAs,\n        querySerializer,\n        bodySerializer\n      });\n      for (const m of middlewares) {\n        if (m && typeof m === \"object\" && typeof m.onRequest === \"function\") {\n          const result = await m.onRequest({\n            request,\n            schemaPath,\n            params,\n            options,\n            id\n          });\n          if (result) {\n            if (result instanceof CustomRequest) {\n              request = result;\n            } else if (result instanceof Response) {\n              response = result;\n              break;\n            } else {\n              throw new Error(\"onRequest: must return new Request() or Response() when modifying the request\");\n            }\n          }\n        }\n      }\n    }\n    if (!response) {\n      try {\n        response = await fetch(request, requestInitExt);\n      } catch (error2) {\n        let errorAfterMiddleware = error2;\n        if (middlewares.length) {\n          for (let i = middlewares.length - 1; i >= 0; i--) {\n            const m = middlewares[i];\n            if (m && typeof m === \"object\" && typeof m.onError === \"function\") {\n              const result = await m.onError({\n                request,\n                error: errorAfterMiddleware,\n                schemaPath,\n                params,\n                options,\n                id\n              });\n              if (result) {\n                if (result instanceof Response) {\n                  errorAfterMiddleware = void 0;\n                  response = result;\n                  break;\n                }\n                if (result instanceof Error) {\n                  errorAfterMiddleware = result;\n                  continue;\n                }\n                throw new Error(\"onError: must return new Response() or instance of Error\");\n              }\n            }\n          }\n        }\n        if (errorAfterMiddleware) {\n          throw errorAfterMiddleware;\n        }\n      }\n      if (middlewares.length) {\n        for (let i = middlewares.length - 1; i >= 0; i--) {\n          const m = middlewares[i];\n          if (m && typeof m === \"object\" && typeof m.onResponse === \"function\") {\n            const result = await m.onResponse({\n              request,\n              response,\n              schemaPath,\n              params,\n              options,\n              id\n            });\n            if (result) {\n              if (!(result instanceof Response)) {\n                throw new Error(\"onResponse: must return new Response() when modifying the response\");\n              }\n              response = result;\n            }\n          }\n        }\n      }\n    }\n    if (response.status === 204 || request.method === \"HEAD\" || response.headers.get(\"Content-Length\") === \"0\") {\n      return response.ok ? { data: void 0, response } : { error: void 0, response };\n    }\n    if (response.ok) {\n      if (parseAs === \"stream\") {\n        return { data: response.body, response };\n      }\n      return { data: await response[parseAs](), response };\n    }\n    let error = await response.text();\n    try {\n      error = JSON.parse(error);\n    } catch {\n    }\n    return { error, response };\n  }\n  return {\n    request(method, url, init) {\n      return coreFetch(url, { ...init, method: method.toUpperCase() });\n    },\n    /** Call a GET endpoint */\n    GET(url, init) {\n      return coreFetch(url, { ...init, method: \"GET\" });\n    },\n    /** Call a PUT endpoint */\n    PUT(url, init) {\n      return coreFetch(url, { ...init, method: \"PUT\" });\n    },\n    /** Call a POST endpoint */\n    POST(url, init) {\n      return coreFetch(url, { ...init, method: \"POST\" });\n    },\n    /** Call a DELETE endpoint */\n    DELETE(url, init) {\n      return coreFetch(url, { ...init, method: \"DELETE\" });\n    },\n    /** Call a OPTIONS endpoint */\n    OPTIONS(url, init) {\n      return coreFetch(url, { ...init, method: \"OPTIONS\" });\n    },\n    /** Call a HEAD endpoint */\n    HEAD(url, init) {\n      return coreFetch(url, { ...init, method: \"HEAD\" });\n    },\n    /** Call a PATCH endpoint */\n    PATCH(url, init) {\n      return coreFetch(url, { ...init, method: \"PATCH\" });\n    },\n    /** Call a TRACE endpoint */\n    TRACE(url, init) {\n      return coreFetch(url, { ...init, method: \"TRACE\" });\n    },\n    /** Register middleware */\n    use(...middleware) {\n      for (const m of middleware) {\n        if (!m) {\n          continue;\n        }\n        if (typeof m !== \"object\" || !(\"onRequest\" in m || \"onResponse\" in m || \"onError\" in m)) {\n          throw new Error(\"Middleware must be an object with one of `onRequest()`, `onResponse() or `onError()`\");\n        }\n        middlewares.push(m);\n      }\n    },\n    /** Unregister middleware */\n    eject(...middleware) {\n      for (const m of middleware) {\n        const i = middlewares.indexOf(m);\n        if (i !== -1) {\n          middlewares.splice(i, 1);\n        }\n      }\n    }\n  };\n}\nvar PathCallForwarder = class {\n  constructor(client, url) {\n    this.client = client;\n    this.url = url;\n  }\n  GET = (init) => {\n    return this.client.GET(this.url, init);\n  };\n  PUT = (init) => {\n    return this.client.PUT(this.url, init);\n  };\n  POST = (init) => {\n    return this.client.POST(this.url, init);\n  };\n  DELETE = (init) => {\n    return this.client.DELETE(this.url, init);\n  };\n  OPTIONS = (init) => {\n    return this.client.OPTIONS(this.url, init);\n  };\n  HEAD = (init) => {\n    return this.client.HEAD(this.url, init);\n  };\n  PATCH = (init) => {\n    return this.client.PATCH(this.url, init);\n  };\n  TRACE = (init) => {\n    return this.client.TRACE(this.url, init);\n  };\n};\nvar PathClientProxyHandler = class {\n  constructor() {\n    this.client = null;\n  }\n  // Assume the property is an URL.\n  get(coreClient, url) {\n    const forwarder = new PathCallForwarder(coreClient, url);\n    this.client[url] = forwarder;\n    return forwarder;\n  }\n};\nfunction wrapAsPathBasedClient(coreClient) {\n  const handler = new PathClientProxyHandler();\n  const proxy = new Proxy(coreClient, handler);\n  function Client() {\n  }\n  Client.prototype = proxy;\n  const client = new Client();\n  handler.client = client;\n  return client;\n}\nfunction createPathBasedClient(clientOptions) {\n  return wrapAsPathBasedClient(createClient(clientOptions));\n}\nfunction serializePrimitiveParam(name, value, options) {\n  if (value === void 0 || value === null) {\n    return \"\";\n  }\n  if (typeof value === \"object\") {\n    throw new Error(\n      \"Deeply-nested arrays/objects aren\\u2019t supported. Provide your own `querySerializer()` to handle these.\"\n    );\n  }\n  return `${name}=${options?.allowReserved === true ? value : encodeURIComponent(value)}`;\n}\nfunction serializeObjectParam(name, value, options) {\n  if (!value || typeof value !== \"object\") {\n    return \"\";\n  }\n  const values = [];\n  const joiner = {\n    simple: \",\",\n    label: \".\",\n    matrix: \";\"\n  }[options.style] || \"&\";\n  if (options.style !== \"deepObject\" && options.explode === false) {\n    for (const k in value) {\n      values.push(k, options.allowReserved === true ? value[k] : encodeURIComponent(value[k]));\n    }\n    const final2 = values.join(\",\");\n    switch (options.style) {\n      case \"form\": {\n        return `${name}=${final2}`;\n      }\n      case \"label\": {\n        return `.${final2}`;\n      }\n      case \"matrix\": {\n        return `;${name}=${final2}`;\n      }\n      default: {\n        return final2;\n      }\n    }\n  }\n  for (const k in value) {\n    const finalName = options.style === \"deepObject\" ? `${name}[${k}]` : k;\n    values.push(serializePrimitiveParam(finalName, value[k], options));\n  }\n  const final = values.join(joiner);\n  return options.style === \"label\" || options.style === \"matrix\" ? `${joiner}${final}` : final;\n}\nfunction serializeArrayParam(name, value, options) {\n  if (!Array.isArray(value)) {\n    return \"\";\n  }\n  if (options.explode === false) {\n    const joiner2 = { form: \",\", spaceDelimited: \"%20\", pipeDelimited: \"|\" }[options.style] || \",\";\n    const final = (options.allowReserved === true ? value : value.map((v) => encodeURIComponent(v))).join(joiner2);\n    switch (options.style) {\n      case \"simple\": {\n        return final;\n      }\n      case \"label\": {\n        return `.${final}`;\n      }\n      case \"matrix\": {\n        return `;${name}=${final}`;\n      }\n      // case \"spaceDelimited\":\n      // case \"pipeDelimited\":\n      default: {\n        return `${name}=${final}`;\n      }\n    }\n  }\n  const joiner = { simple: \",\", label: \".\", matrix: \";\" }[options.style] || \"&\";\n  const values = [];\n  for (const v of value) {\n    if (options.style === \"simple\" || options.style === \"label\") {\n      values.push(options.allowReserved === true ? v : encodeURIComponent(v));\n    } else {\n      values.push(serializePrimitiveParam(name, v, options));\n    }\n  }\n  return options.style === \"label\" || options.style === \"matrix\" ? `${joiner}${values.join(joiner)}` : values.join(joiner);\n}\nfunction createQuerySerializer(options) {\n  return function querySerializer(queryParams) {\n    const search = [];\n    if (queryParams && typeof queryParams === \"object\") {\n      for (const name in queryParams) {\n        const value = queryParams[name];\n        if (value === void 0 || value === null) {\n          continue;\n        }\n        if (Array.isArray(value)) {\n          if (value.length === 0) {\n            continue;\n          }\n          search.push(\n            serializeArrayParam(name, value, {\n              style: \"form\",\n              explode: true,\n              ...options?.array,\n              allowReserved: options?.allowReserved || false\n            })\n          );\n          continue;\n        }\n        if (typeof value === \"object\") {\n          search.push(\n            serializeObjectParam(name, value, {\n              style: \"deepObject\",\n              explode: true,\n              ...options?.object,\n              allowReserved: options?.allowReserved || false\n            })\n          );\n          continue;\n        }\n        search.push(serializePrimitiveParam(name, value, options));\n      }\n    }\n    return search.join(\"&\");\n  };\n}\nfunction defaultPathSerializer(pathname, pathParams) {\n  let nextURL = pathname;\n  for (const match of pathname.match(PATH_PARAM_RE) ?? []) {\n    let name = match.substring(1, match.length - 1);\n    let explode = false;\n    let style = \"simple\";\n    if (name.endsWith(\"*\")) {\n      explode = true;\n      name = name.substring(0, name.length - 1);\n    }\n    if (name.startsWith(\".\")) {\n      style = \"label\";\n      name = name.substring(1);\n    } else if (name.startsWith(\";\")) {\n      style = \"matrix\";\n      name = name.substring(1);\n    }\n    if (!pathParams || pathParams[name] === void 0 || pathParams[name] === null) {\n      continue;\n    }\n    const value = pathParams[name];\n    if (Array.isArray(value)) {\n      nextURL = nextURL.replace(match, serializeArrayParam(name, value, { style, explode }));\n      continue;\n    }\n    if (typeof value === \"object\") {\n      nextURL = nextURL.replace(match, serializeObjectParam(name, value, { style, explode }));\n      continue;\n    }\n    if (style === \"matrix\") {\n      nextURL = nextURL.replace(match, `;${serializePrimitiveParam(name, value)}`);\n      continue;\n    }\n    nextURL = nextURL.replace(match, style === \"label\" ? `.${encodeURIComponent(value)}` : encodeURIComponent(value));\n  }\n  return nextURL;\n}\nfunction defaultBodySerializer(body, headers) {\n  if (body instanceof FormData) {\n    return body;\n  }\n  if (headers) {\n    const contentType = headers.get instanceof Function ? headers.get(\"Content-Type\") ?? headers.get(\"content-type\") : headers[\"Content-Type\"] ?? headers[\"content-type\"];\n    if (contentType === \"application/x-www-form-urlencoded\") {\n      return new URLSearchParams(body).toString();\n    }\n  }\n  return JSON.stringify(body);\n}\nfunction createFinalURL(pathname, options) {\n  let finalURL = `${options.baseUrl}${pathname}`;\n  if (options.params?.path) {\n    finalURL = defaultPathSerializer(finalURL, options.params.path);\n  }\n  let search = options.querySerializer(options.params.query ?? {});\n  if (search.startsWith(\"?\")) {\n    search = search.substring(1);\n  }\n  if (search) {\n    finalURL += `?${search}`;\n  }\n  return finalURL;\n}\nfunction mergeHeaders(...allHeaders) {\n  const finalHeaders = new Headers();\n  for (const h of allHeaders) {\n    if (!h || typeof h !== \"object\") {\n      continue;\n    }\n    const iterator = h instanceof Headers ? h.entries() : Object.entries(h);\n    for (const [k, v] of iterator) {\n      if (v === null) {\n        finalHeaders.delete(k);\n      } else if (Array.isArray(v)) {\n        for (const v2 of v) {\n          finalHeaders.append(k, v2);\n        }\n      } else if (v !== void 0) {\n        finalHeaders.set(k, v);\n      }\n    }\n  }\n  return finalHeaders;\n}\nfunction removeTrailingSlash(url) {\n  if (url.endsWith(\"/\")) {\n    return url.substring(0, url.length - 1);\n  }\n  return url;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3BlbmFwaS1mZXRjaC9kaXN0L2Nqcy9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx1QkFBdUIsSUFBSSxJQUFJO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFLDhDQUE4QztBQUM5QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdEQUFnRDtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtB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QUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NpbHZpcy9Eb2N1bWVudHMvcmV2b2x1Y2FvLWNpYmVybmV0aWNhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9vcGVuYXBpLWZldGNoL2Rpc3QvY2pzL2luZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG5cbi8vIHNyYy9pbmRleC5qc1xudmFyIGluZGV4X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGluZGV4X2V4cG9ydHMsIHtcbiAgY3JlYXRlRmluYWxVUkw6ICgpID0+IGNyZWF0ZUZpbmFsVVJMLFxuICBjcmVhdGVQYXRoQmFzZWRDbGllbnQ6ICgpID0+IGNyZWF0ZVBhdGhCYXNlZENsaWVudCxcbiAgY3JlYXRlUXVlcnlTZXJpYWxpemVyOiAoKSA9PiBjcmVhdGVRdWVyeVNlcmlhbGl6ZXIsXG4gIGRlZmF1bHQ6ICgpID0+IGNyZWF0ZUNsaWVudCxcbiAgZGVmYXVsdEJvZHlTZXJpYWxpemVyOiAoKSA9PiBkZWZhdWx0Qm9keVNlcmlhbGl6ZXIsXG4gIGRlZmF1bHRQYXRoU2VyaWFsaXplcjogKCkgPT4gZGVmYXVsdFBhdGhTZXJpYWxpemVyLFxuICBtZXJnZUhlYWRlcnM6ICgpID0+IG1lcmdlSGVhZGVycyxcbiAgcmFuZG9tSUQ6ICgpID0+IHJhbmRvbUlELFxuICByZW1vdmVUcmFpbGluZ1NsYXNoOiAoKSA9PiByZW1vdmVUcmFpbGluZ1NsYXNoLFxuICBzZXJpYWxpemVBcnJheVBhcmFtOiAoKSA9PiBzZXJpYWxpemVBcnJheVBhcmFtLFxuICBzZXJpYWxpemVPYmplY3RQYXJhbTogKCkgPT4gc2VyaWFsaXplT2JqZWN0UGFyYW0sXG4gIHNlcmlhbGl6ZVByaW1pdGl2ZVBhcmFtOiAoKSA9PiBzZXJpYWxpemVQcmltaXRpdmVQYXJhbSxcbiAgd3JhcEFzUGF0aEJhc2VkQ2xpZW50OiAoKSA9PiB3cmFwQXNQYXRoQmFzZWRDbGllbnRcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoaW5kZXhfZXhwb3J0cyk7XG52YXIgUEFUSF9QQVJBTV9SRSA9IC9cXHtbXnt9XStcXH0vZztcbnZhciBzdXBwb3J0c1JlcXVlc3RJbml0RXh0ID0gKCkgPT4ge1xuICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgTnVtYmVyLnBhcnNlSW50KHByb2Nlc3M/LnZlcnNpb25zPy5ub2RlPy5zdWJzdHJpbmcoMCwgMikpID49IDE4ICYmIHByb2Nlc3MudmVyc2lvbnMudW5kaWNpO1xufTtcbmZ1bmN0aW9uIHJhbmRvbUlEKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwgMTEpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50KGNsaWVudE9wdGlvbnMpIHtcbiAgbGV0IHtcbiAgICBiYXNlVXJsID0gXCJcIixcbiAgICBSZXF1ZXN0OiBDdXN0b21SZXF1ZXN0ID0gZ2xvYmFsVGhpcy5SZXF1ZXN0LFxuICAgIGZldGNoOiBiYXNlRmV0Y2ggPSBnbG9iYWxUaGlzLmZldGNoLFxuICAgIHF1ZXJ5U2VyaWFsaXplcjogZ2xvYmFsUXVlcnlTZXJpYWxpemVyLFxuICAgIGJvZHlTZXJpYWxpemVyOiBnbG9iYWxCb2R5U2VyaWFsaXplcixcbiAgICBoZWFkZXJzOiBiYXNlSGVhZGVycyxcbiAgICByZXF1ZXN0SW5pdEV4dCA9IHZvaWQgMCxcbiAgICAuLi5iYXNlT3B0aW9uc1xuICB9ID0geyAuLi5jbGllbnRPcHRpb25zIH07XG4gIHJlcXVlc3RJbml0RXh0ID0gc3VwcG9ydHNSZXF1ZXN0SW5pdEV4dCgpID8gcmVxdWVzdEluaXRFeHQgOiB2b2lkIDA7XG4gIGJhc2VVcmwgPSByZW1vdmVUcmFpbGluZ1NsYXNoKGJhc2VVcmwpO1xuICBjb25zdCBtaWRkbGV3YXJlcyA9IFtdO1xuICBhc3luYyBmdW5jdGlvbiBjb3JlRmV0Y2goc2NoZW1hUGF0aCwgZmV0Y2hPcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgYmFzZVVybDogbG9jYWxCYXNlVXJsLFxuICAgICAgZmV0Y2ggPSBiYXNlRmV0Y2gsXG4gICAgICBSZXF1ZXN0ID0gQ3VzdG9tUmVxdWVzdCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBwYXJhbXMgPSB7fSxcbiAgICAgIHBhcnNlQXMgPSBcImpzb25cIixcbiAgICAgIHF1ZXJ5U2VyaWFsaXplcjogcmVxdWVzdFF1ZXJ5U2VyaWFsaXplcixcbiAgICAgIGJvZHlTZXJpYWxpemVyID0gZ2xvYmFsQm9keVNlcmlhbGl6ZXIgPz8gZGVmYXVsdEJvZHlTZXJpYWxpemVyLFxuICAgICAgYm9keSxcbiAgICAgIC4uLmluaXRcbiAgICB9ID0gZmV0Y2hPcHRpb25zIHx8IHt9O1xuICAgIGxldCBmaW5hbEJhc2VVcmwgPSBiYXNlVXJsO1xuICAgIGlmIChsb2NhbEJhc2VVcmwpIHtcbiAgICAgIGZpbmFsQmFzZVVybCA9IHJlbW92ZVRyYWlsaW5nU2xhc2gobG9jYWxCYXNlVXJsKSA/PyBiYXNlVXJsO1xuICAgIH1cbiAgICBsZXQgcXVlcnlTZXJpYWxpemVyID0gdHlwZW9mIGdsb2JhbFF1ZXJ5U2VyaWFsaXplciA9PT0gXCJmdW5jdGlvblwiID8gZ2xvYmFsUXVlcnlTZXJpYWxpemVyIDogY3JlYXRlUXVlcnlTZXJpYWxpemVyKGdsb2JhbFF1ZXJ5U2VyaWFsaXplcik7XG4gICAgaWYgKHJlcXVlc3RRdWVyeVNlcmlhbGl6ZXIpIHtcbiAgICAgIHF1ZXJ5U2VyaWFsaXplciA9IHR5cGVvZiByZXF1ZXN0UXVlcnlTZXJpYWxpemVyID09PSBcImZ1bmN0aW9uXCIgPyByZXF1ZXN0UXVlcnlTZXJpYWxpemVyIDogY3JlYXRlUXVlcnlTZXJpYWxpemVyKHtcbiAgICAgICAgLi4udHlwZW9mIGdsb2JhbFF1ZXJ5U2VyaWFsaXplciA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbFF1ZXJ5U2VyaWFsaXplciA6IHt9LFxuICAgICAgICAuLi5yZXF1ZXN0UXVlcnlTZXJpYWxpemVyXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWFsaXplZEJvZHkgPSBib2R5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBib2R5U2VyaWFsaXplcihcbiAgICAgIGJvZHksXG4gICAgICAvLyBOb3RlOiB3ZSBkZWNsYXJlIG1lcmdlSGVhZGVycygpIGJvdGggaGVyZSBhbmQgYmVsb3cgYmVjYXVzZSBpdOKAmXMgYSBiaXQgb2YgYSBjaGlja2VuLW9yLWVnZyBzaXR1YXRpb246XG4gICAgICAvLyBib2R5U2VyaWFsaXplcigpIG5lZWRzIGFsbCBoZWFkZXJzIHNvIHdlIGFyZW7igJl0IGRyb3BwaW5nIG9uZXMgc2V0IGJ5IHRoZSB1c2VyLCBob3dldmVyLFxuICAgICAgLy8gdGhlIHJlc3VsdCBvZiB0aGlzIEFMU08gc2V0cyB0aGUgbG93ZXN0LXByaW9yaXR5IGNvbnRlbnQtdHlwZSBoZWFkZXIuIFNvIHdlIHJlLW1lcmdlIGJlbG93LFxuICAgICAgLy8gc2V0dGluZyB0aGUgY29udGVudC10eXBlIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyB0byBiZSBvdmVyd3JpdHRlbi5cbiAgICAgIC8vIExhc3RseSwgYmFzZWQgb24gdGhlIHdheSBoZWFkZXJzIHdvcmssIGl04oCZcyBub3QgYSBzaW1wbGXCoOKAnHByZXNlbnQtb3Itbm904oCdIGNoZWNrIGJlY2F1YXNlIG51bGwgaW50ZW50aW9uYWxseSB1bi1zZXRzIGhlYWRlcnMuXG4gICAgICBtZXJnZUhlYWRlcnMoYmFzZUhlYWRlcnMsIGhlYWRlcnMsIHBhcmFtcy5oZWFkZXIpXG4gICAgKTtcbiAgICBjb25zdCBmaW5hbEhlYWRlcnMgPSBtZXJnZUhlYWRlcnMoXG4gICAgICAvLyB3aXRoIG5vIGJvZHksIHdlIHNob3VsZCBub3QgdG8gc2V0IENvbnRlbnQtVHlwZVxuICAgICAgc2VyaWFsaXplZEJvZHkgPT09IHZvaWQgMCB8fCAvLyBpZiBzZXJpYWxpemVkIGJvZHkgaXMgRm9ybURhdGE7IGJyb3dzZXIgd2lsbCBjb3JyZWN0bHkgc2V0IENvbnRlbnQtVHlwZSAmIGJvdW5kYXJ5IGV4cHJlc3Npb25cbiAgICAgIHNlcmlhbGl6ZWRCb2R5IGluc3RhbmNlb2YgRm9ybURhdGEgPyB7fSA6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgIH0sXG4gICAgICBiYXNlSGVhZGVycyxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBwYXJhbXMuaGVhZGVyXG4gICAgKTtcbiAgICBjb25zdCByZXF1ZXN0SW5pdCA9IHtcbiAgICAgIHJlZGlyZWN0OiBcImZvbGxvd1wiLFxuICAgICAgLi4uYmFzZU9wdGlvbnMsXG4gICAgICAuLi5pbml0LFxuICAgICAgYm9keTogc2VyaWFsaXplZEJvZHksXG4gICAgICBoZWFkZXJzOiBmaW5hbEhlYWRlcnNcbiAgICB9O1xuICAgIGxldCBpZDtcbiAgICBsZXQgb3B0aW9ucztcbiAgICBsZXQgcmVxdWVzdCA9IG5ldyBDdXN0b21SZXF1ZXN0KFxuICAgICAgY3JlYXRlRmluYWxVUkwoc2NoZW1hUGF0aCwgeyBiYXNlVXJsOiBmaW5hbEJhc2VVcmwsIHBhcmFtcywgcXVlcnlTZXJpYWxpemVyIH0pLFxuICAgICAgcmVxdWVzdEluaXRcbiAgICApO1xuICAgIGxldCByZXNwb25zZTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbml0KSB7XG4gICAgICBpZiAoIShrZXkgaW4gcmVxdWVzdCkpIHtcbiAgICAgICAgcmVxdWVzdFtrZXldID0gaW5pdFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWlkZGxld2FyZXMubGVuZ3RoKSB7XG4gICAgICBpZCA9IHJhbmRvbUlEKCk7XG4gICAgICBvcHRpb25zID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGJhc2VVcmw6IGZpbmFsQmFzZVVybCxcbiAgICAgICAgZmV0Y2gsXG4gICAgICAgIHBhcnNlQXMsXG4gICAgICAgIHF1ZXJ5U2VyaWFsaXplcixcbiAgICAgICAgYm9keVNlcmlhbGl6ZXJcbiAgICAgIH0pO1xuICAgICAgZm9yIChjb25zdCBtIG9mIG1pZGRsZXdhcmVzKSB7XG4gICAgICAgIGlmIChtICYmIHR5cGVvZiBtID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtLm9uUmVxdWVzdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbS5vblJlcXVlc3Qoe1xuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHNjaGVtYVBhdGgsXG4gICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgaWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgQ3VzdG9tUmVxdWVzdCkge1xuICAgICAgICAgICAgICByZXF1ZXN0ID0gcmVzdWx0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICAgICAgICByZXNwb25zZSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvblJlcXVlc3Q6IG11c3QgcmV0dXJuIG5ldyBSZXF1ZXN0KCkgb3IgUmVzcG9uc2UoKSB3aGVuIG1vZGlmeWluZyB0aGUgcmVxdWVzdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXF1ZXN0LCByZXF1ZXN0SW5pdEV4dCk7XG4gICAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgICAgbGV0IGVycm9yQWZ0ZXJNaWRkbGV3YXJlID0gZXJyb3IyO1xuICAgICAgICBpZiAobWlkZGxld2FyZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IG1pZGRsZXdhcmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBtID0gbWlkZGxld2FyZXNbaV07XG4gICAgICAgICAgICBpZiAobSAmJiB0eXBlb2YgbSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbS5vbkVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbS5vbkVycm9yKHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvckFmdGVyTWlkZGxld2FyZSxcbiAgICAgICAgICAgICAgICBzY2hlbWFQYXRoLFxuICAgICAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvckFmdGVyTWlkZGxld2FyZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgZXJyb3JBZnRlck1pZGRsZXdhcmUgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib25FcnJvcjogbXVzdCByZXR1cm4gbmV3IFJlc3BvbnNlKCkgb3IgaW5zdGFuY2Ugb2YgRXJyb3JcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yQWZ0ZXJNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3JBZnRlck1pZGRsZXdhcmU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtaWRkbGV3YXJlcy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IG1pZGRsZXdhcmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgbSA9IG1pZGRsZXdhcmVzW2ldO1xuICAgICAgICAgIGlmIChtICYmIHR5cGVvZiBtID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtLm9uUmVzcG9uc2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbS5vblJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgIHNjaGVtYVBhdGgsXG4gICAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICBpZiAoIShyZXN1bHQgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvblJlc3BvbnNlOiBtdXN0IHJldHVybiBuZXcgUmVzcG9uc2UoKSB3aGVuIG1vZGlmeWluZyB0aGUgcmVzcG9uc2VcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzcG9uc2UgPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwNCB8fCByZXF1ZXN0Lm1ldGhvZCA9PT0gXCJIRUFEXCIgfHwgcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJDb250ZW50LUxlbmd0aFwiKSA9PT0gXCIwXCIpIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5vayA/IHsgZGF0YTogdm9pZCAwLCByZXNwb25zZSB9IDogeyBlcnJvcjogdm9pZCAwLCByZXNwb25zZSB9O1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIGlmIChwYXJzZUFzID09PSBcInN0cmVhbVwiKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHJlc3BvbnNlLmJvZHksIHJlc3BvbnNlIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyBkYXRhOiBhd2FpdCByZXNwb25zZVtwYXJzZUFzXSgpLCByZXNwb25zZSB9O1xuICAgIH1cbiAgICBsZXQgZXJyb3IgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgdHJ5IHtcbiAgICAgIGVycm9yID0gSlNPTi5wYXJzZShlcnJvcik7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIHJldHVybiB7IGVycm9yLCByZXNwb25zZSB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVxdWVzdChtZXRob2QsIHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBtZXRob2QudG9VcHBlckNhc2UoKSB9KTtcbiAgICB9LFxuICAgIC8qKiBDYWxsIGEgR0VUIGVuZHBvaW50ICovXG4gICAgR0VUKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIkdFVFwiIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBQVVQgZW5kcG9pbnQgKi9cbiAgICBQVVQodXJsLCBpbml0KSB7XG4gICAgICByZXR1cm4gY29yZUZldGNoKHVybCwgeyAuLi5pbml0LCBtZXRob2Q6IFwiUFVUXCIgfSk7XG4gICAgfSxcbiAgICAvKiogQ2FsbCBhIFBPU1QgZW5kcG9pbnQgKi9cbiAgICBQT1NUKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIlBPU1RcIiB9KTtcbiAgICB9LFxuICAgIC8qKiBDYWxsIGEgREVMRVRFIGVuZHBvaW50ICovXG4gICAgREVMRVRFKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIkRFTEVURVwiIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBPUFRJT05TIGVuZHBvaW50ICovXG4gICAgT1BUSU9OUyh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJPUFRJT05TXCIgfSk7XG4gICAgfSxcbiAgICAvKiogQ2FsbCBhIEhFQUQgZW5kcG9pbnQgKi9cbiAgICBIRUFEKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIkhFQURcIiB9KTtcbiAgICB9LFxuICAgIC8qKiBDYWxsIGEgUEFUQ0ggZW5kcG9pbnQgKi9cbiAgICBQQVRDSCh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJQQVRDSFwiIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBUUkFDRSBlbmRwb2ludCAqL1xuICAgIFRSQUNFKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIlRSQUNFXCIgfSk7XG4gICAgfSxcbiAgICAvKiogUmVnaXN0ZXIgbWlkZGxld2FyZSAqL1xuICAgIHVzZSguLi5taWRkbGV3YXJlKSB7XG4gICAgICBmb3IgKGNvbnN0IG0gb2YgbWlkZGxld2FyZSkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG0gIT09IFwib2JqZWN0XCIgfHwgIShcIm9uUmVxdWVzdFwiIGluIG0gfHwgXCJvblJlc3BvbnNlXCIgaW4gbSB8fCBcIm9uRXJyb3JcIiBpbiBtKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pZGRsZXdhcmUgbXVzdCBiZSBhbiBvYmplY3Qgd2l0aCBvbmUgb2YgYG9uUmVxdWVzdCgpYCwgYG9uUmVzcG9uc2UoKSBvciBgb25FcnJvcigpYFwiKTtcbiAgICAgICAgfVxuICAgICAgICBtaWRkbGV3YXJlcy5wdXNoKG0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqIFVucmVnaXN0ZXIgbWlkZGxld2FyZSAqL1xuICAgIGVqZWN0KC4uLm1pZGRsZXdhcmUpIHtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBtaWRkbGV3YXJlKSB7XG4gICAgICAgIGNvbnN0IGkgPSBtaWRkbGV3YXJlcy5pbmRleE9mKG0pO1xuICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICBtaWRkbGV3YXJlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG52YXIgUGF0aENhbGxGb3J3YXJkZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgdXJsKSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gIH1cbiAgR0VUID0gKGluaXQpID0+IHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuR0VUKHRoaXMudXJsLCBpbml0KTtcbiAgfTtcbiAgUFVUID0gKGluaXQpID0+IHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuUFVUKHRoaXMudXJsLCBpbml0KTtcbiAgfTtcbiAgUE9TVCA9IChpbml0KSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LlBPU1QodGhpcy51cmwsIGluaXQpO1xuICB9O1xuICBERUxFVEUgPSAoaW5pdCkgPT4ge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5ERUxFVEUodGhpcy51cmwsIGluaXQpO1xuICB9O1xuICBPUFRJT05TID0gKGluaXQpID0+IHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuT1BUSU9OUyh0aGlzLnVybCwgaW5pdCk7XG4gIH07XG4gIEhFQUQgPSAoaW5pdCkgPT4ge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5IRUFEKHRoaXMudXJsLCBpbml0KTtcbiAgfTtcbiAgUEFUQ0ggPSAoaW5pdCkgPT4ge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5QQVRDSCh0aGlzLnVybCwgaW5pdCk7XG4gIH07XG4gIFRSQUNFID0gKGluaXQpID0+IHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuVFJBQ0UodGhpcy51cmwsIGluaXQpO1xuICB9O1xufTtcbnZhciBQYXRoQ2xpZW50UHJveHlIYW5kbGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNsaWVudCA9IG51bGw7XG4gIH1cbiAgLy8gQXNzdW1lIHRoZSBwcm9wZXJ0eSBpcyBhbiBVUkwuXG4gIGdldChjb3JlQ2xpZW50LCB1cmwpIHtcbiAgICBjb25zdCBmb3J3YXJkZXIgPSBuZXcgUGF0aENhbGxGb3J3YXJkZXIoY29yZUNsaWVudCwgdXJsKTtcbiAgICB0aGlzLmNsaWVudFt1cmxdID0gZm9yd2FyZGVyO1xuICAgIHJldHVybiBmb3J3YXJkZXI7XG4gIH1cbn07XG5mdW5jdGlvbiB3cmFwQXNQYXRoQmFzZWRDbGllbnQoY29yZUNsaWVudCkge1xuICBjb25zdCBoYW5kbGVyID0gbmV3IFBhdGhDbGllbnRQcm94eUhhbmRsZXIoKTtcbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoY29yZUNsaWVudCwgaGFuZGxlcik7XG4gIGZ1bmN0aW9uIENsaWVudCgpIHtcbiAgfVxuICBDbGllbnQucHJvdG90eXBlID0gcHJveHk7XG4gIGNvbnN0IGNsaWVudCA9IG5ldyBDbGllbnQoKTtcbiAgaGFuZGxlci5jbGllbnQgPSBjbGllbnQ7XG4gIHJldHVybiBjbGllbnQ7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRoQmFzZWRDbGllbnQoY2xpZW50T3B0aW9ucykge1xuICByZXR1cm4gd3JhcEFzUGF0aEJhc2VkQ2xpZW50KGNyZWF0ZUNsaWVudChjbGllbnRPcHRpb25zKSk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVQcmltaXRpdmVQYXJhbShuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAodmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkRlZXBseS1uZXN0ZWQgYXJyYXlzL29iamVjdHMgYXJlblxcdTIwMTl0IHN1cHBvcnRlZC4gUHJvdmlkZSB5b3VyIG93biBgcXVlcnlTZXJpYWxpemVyKClgIHRvIGhhbmRsZSB0aGVzZS5cIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGAke25hbWV9PSR7b3B0aW9ucz8uYWxsb3dSZXNlcnZlZCA9PT0gdHJ1ZSA/IHZhbHVlIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKX1gO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplT2JqZWN0UGFyYW0obmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgY29uc3Qgam9pbmVyID0ge1xuICAgIHNpbXBsZTogXCIsXCIsXG4gICAgbGFiZWw6IFwiLlwiLFxuICAgIG1hdHJpeDogXCI7XCJcbiAgfVtvcHRpb25zLnN0eWxlXSB8fCBcIiZcIjtcbiAgaWYgKG9wdGlvbnMuc3R5bGUgIT09IFwiZGVlcE9iamVjdFwiICYmIG9wdGlvbnMuZXhwbG9kZSA9PT0gZmFsc2UpIHtcbiAgICBmb3IgKGNvbnN0IGsgaW4gdmFsdWUpIHtcbiAgICAgIHZhbHVlcy5wdXNoKGssIG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9PT0gdHJ1ZSA/IHZhbHVlW2tdIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlW2tdKSk7XG4gICAgfVxuICAgIGNvbnN0IGZpbmFsMiA9IHZhbHVlcy5qb2luKFwiLFwiKTtcbiAgICBzd2l0Y2ggKG9wdGlvbnMuc3R5bGUpIHtcbiAgICAgIGNhc2UgXCJmb3JtXCI6IHtcbiAgICAgICAgcmV0dXJuIGAke25hbWV9PSR7ZmluYWwyfWA7XG4gICAgICB9XG4gICAgICBjYXNlIFwibGFiZWxcIjoge1xuICAgICAgICByZXR1cm4gYC4ke2ZpbmFsMn1gO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm1hdHJpeFwiOiB7XG4gICAgICAgIHJldHVybiBgOyR7bmFtZX09JHtmaW5hbDJ9YDtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgcmV0dXJuIGZpbmFsMjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBrIGluIHZhbHVlKSB7XG4gICAgY29uc3QgZmluYWxOYW1lID0gb3B0aW9ucy5zdHlsZSA9PT0gXCJkZWVwT2JqZWN0XCIgPyBgJHtuYW1lfVske2t9XWAgOiBrO1xuICAgIHZhbHVlcy5wdXNoKHNlcmlhbGl6ZVByaW1pdGl2ZVBhcmFtKGZpbmFsTmFtZSwgdmFsdWVba10sIG9wdGlvbnMpKTtcbiAgfVxuICBjb25zdCBmaW5hbCA9IHZhbHVlcy5qb2luKGpvaW5lcik7XG4gIHJldHVybiBvcHRpb25zLnN0eWxlID09PSBcImxhYmVsXCIgfHwgb3B0aW9ucy5zdHlsZSA9PT0gXCJtYXRyaXhcIiA/IGAke2pvaW5lcn0ke2ZpbmFsfWAgOiBmaW5hbDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUFycmF5UGFyYW0obmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGlmIChvcHRpb25zLmV4cGxvZGUgPT09IGZhbHNlKSB7XG4gICAgY29uc3Qgam9pbmVyMiA9IHsgZm9ybTogXCIsXCIsIHNwYWNlRGVsaW1pdGVkOiBcIiUyMFwiLCBwaXBlRGVsaW1pdGVkOiBcInxcIiB9W29wdGlvbnMuc3R5bGVdIHx8IFwiLFwiO1xuICAgIGNvbnN0IGZpbmFsID0gKG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9PT0gdHJ1ZSA/IHZhbHVlIDogdmFsdWUubWFwKCh2KSA9PiBlbmNvZGVVUklDb21wb25lbnQodikpKS5qb2luKGpvaW5lcjIpO1xuICAgIHN3aXRjaCAob3B0aW9ucy5zdHlsZSkge1xuICAgICAgY2FzZSBcInNpbXBsZVwiOiB7XG4gICAgICAgIHJldHVybiBmaW5hbDtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJsYWJlbFwiOiB7XG4gICAgICAgIHJldHVybiBgLiR7ZmluYWx9YDtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJtYXRyaXhcIjoge1xuICAgICAgICByZXR1cm4gYDske25hbWV9PSR7ZmluYWx9YDtcbiAgICAgIH1cbiAgICAgIC8vIGNhc2UgXCJzcGFjZURlbGltaXRlZFwiOlxuICAgICAgLy8gY2FzZSBcInBpcGVEZWxpbWl0ZWRcIjpcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgcmV0dXJuIGAke25hbWV9PSR7ZmluYWx9YDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3Qgam9pbmVyID0geyBzaW1wbGU6IFwiLFwiLCBsYWJlbDogXCIuXCIsIG1hdHJpeDogXCI7XCIgfVtvcHRpb25zLnN0eWxlXSB8fCBcIiZcIjtcbiAgY29uc3QgdmFsdWVzID0gW107XG4gIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgIGlmIChvcHRpb25zLnN0eWxlID09PSBcInNpbXBsZVwiIHx8IG9wdGlvbnMuc3R5bGUgPT09IFwibGFiZWxcIikge1xuICAgICAgdmFsdWVzLnB1c2gob3B0aW9ucy5hbGxvd1Jlc2VydmVkID09PSB0cnVlID8gdiA6IGVuY29kZVVSSUNvbXBvbmVudCh2KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlcy5wdXNoKHNlcmlhbGl6ZVByaW1pdGl2ZVBhcmFtKG5hbWUsIHYsIG9wdGlvbnMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnMuc3R5bGUgPT09IFwibGFiZWxcIiB8fCBvcHRpb25zLnN0eWxlID09PSBcIm1hdHJpeFwiID8gYCR7am9pbmVyfSR7dmFsdWVzLmpvaW4oam9pbmVyKX1gIDogdmFsdWVzLmpvaW4oam9pbmVyKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVF1ZXJ5U2VyaWFsaXplcihvcHRpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBxdWVyeVNlcmlhbGl6ZXIocXVlcnlQYXJhbXMpIHtcbiAgICBjb25zdCBzZWFyY2ggPSBbXTtcbiAgICBpZiAocXVlcnlQYXJhbXMgJiYgdHlwZW9mIHF1ZXJ5UGFyYW1zID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBxdWVyeVBhcmFtc1tuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDAgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VhcmNoLnB1c2goXG4gICAgICAgICAgICBzZXJpYWxpemVBcnJheVBhcmFtKG5hbWUsIHZhbHVlLCB7XG4gICAgICAgICAgICAgIHN0eWxlOiBcImZvcm1cIixcbiAgICAgICAgICAgICAgZXhwbG9kZTogdHJ1ZSxcbiAgICAgICAgICAgICAgLi4ub3B0aW9ucz8uYXJyYXksXG4gICAgICAgICAgICAgIGFsbG93UmVzZXJ2ZWQ6IG9wdGlvbnM/LmFsbG93UmVzZXJ2ZWQgfHwgZmFsc2VcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgc2VhcmNoLnB1c2goXG4gICAgICAgICAgICBzZXJpYWxpemVPYmplY3RQYXJhbShuYW1lLCB2YWx1ZSwge1xuICAgICAgICAgICAgICBzdHlsZTogXCJkZWVwT2JqZWN0XCIsXG4gICAgICAgICAgICAgIGV4cGxvZGU6IHRydWUsXG4gICAgICAgICAgICAgIC4uLm9wdGlvbnM/Lm9iamVjdCxcbiAgICAgICAgICAgICAgYWxsb3dSZXNlcnZlZDogb3B0aW9ucz8uYWxsb3dSZXNlcnZlZCB8fCBmYWxzZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHNlYXJjaC5wdXNoKHNlcmlhbGl6ZVByaW1pdGl2ZVBhcmFtKG5hbWUsIHZhbHVlLCBvcHRpb25zKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWFyY2guam9pbihcIiZcIik7XG4gIH07XG59XG5mdW5jdGlvbiBkZWZhdWx0UGF0aFNlcmlhbGl6ZXIocGF0aG5hbWUsIHBhdGhQYXJhbXMpIHtcbiAgbGV0IG5leHRVUkwgPSBwYXRobmFtZTtcbiAgZm9yIChjb25zdCBtYXRjaCBvZiBwYXRobmFtZS5tYXRjaChQQVRIX1BBUkFNX1JFKSA/PyBbXSkge1xuICAgIGxldCBuYW1lID0gbWF0Y2guc3Vic3RyaW5nKDEsIG1hdGNoLmxlbmd0aCAtIDEpO1xuICAgIGxldCBleHBsb2RlID0gZmFsc2U7XG4gICAgbGV0IHN0eWxlID0gXCJzaW1wbGVcIjtcbiAgICBpZiAobmFtZS5lbmRzV2l0aChcIipcIikpIHtcbiAgICAgIGV4cGxvZGUgPSB0cnVlO1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCIuXCIpKSB7XG4gICAgICBzdHlsZSA9IFwibGFiZWxcIjtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygxKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUuc3RhcnRzV2l0aChcIjtcIikpIHtcbiAgICAgIHN0eWxlID0gXCJtYXRyaXhcIjtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgaWYgKCFwYXRoUGFyYW1zIHx8IHBhdGhQYXJhbXNbbmFtZV0gPT09IHZvaWQgMCB8fCBwYXRoUGFyYW1zW25hbWVdID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBwYXRoUGFyYW1zW25hbWVdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgbmV4dFVSTCA9IG5leHRVUkwucmVwbGFjZShtYXRjaCwgc2VyaWFsaXplQXJyYXlQYXJhbShuYW1lLCB2YWx1ZSwgeyBzdHlsZSwgZXhwbG9kZSB9KSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgbmV4dFVSTCA9IG5leHRVUkwucmVwbGFjZShtYXRjaCwgc2VyaWFsaXplT2JqZWN0UGFyYW0obmFtZSwgdmFsdWUsIHsgc3R5bGUsIGV4cGxvZGUgfSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChzdHlsZSA9PT0gXCJtYXRyaXhcIikge1xuICAgICAgbmV4dFVSTCA9IG5leHRVUkwucmVwbGFjZShtYXRjaCwgYDske3NlcmlhbGl6ZVByaW1pdGl2ZVBhcmFtKG5hbWUsIHZhbHVlKX1gKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBuZXh0VVJMID0gbmV4dFVSTC5yZXBsYWNlKG1hdGNoLCBzdHlsZSA9PT0gXCJsYWJlbFwiID8gYC4ke2VuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSl9YCA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiBuZXh0VVJMO1xufVxuZnVuY3Rpb24gZGVmYXVsdEJvZHlTZXJpYWxpemVyKGJvZHksIGhlYWRlcnMpIHtcbiAgaWYgKGJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgIHJldHVybiBib2R5O1xuICB9XG4gIGlmIChoZWFkZXJzKSB7XG4gICAgY29uc3QgY29udGVudFR5cGUgPSBoZWFkZXJzLmdldCBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIikgPz8gaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikgOiBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID8/IGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl07XG4gICAgaWYgKGNvbnRlbnRUeXBlID09PSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSB7XG4gICAgICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyhib2R5KS50b1N0cmluZygpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG59XG5mdW5jdGlvbiBjcmVhdGVGaW5hbFVSTChwYXRobmFtZSwgb3B0aW9ucykge1xuICBsZXQgZmluYWxVUkwgPSBgJHtvcHRpb25zLmJhc2VVcmx9JHtwYXRobmFtZX1gO1xuICBpZiAob3B0aW9ucy5wYXJhbXM/LnBhdGgpIHtcbiAgICBmaW5hbFVSTCA9IGRlZmF1bHRQYXRoU2VyaWFsaXplcihmaW5hbFVSTCwgb3B0aW9ucy5wYXJhbXMucGF0aCk7XG4gIH1cbiAgbGV0IHNlYXJjaCA9IG9wdGlvbnMucXVlcnlTZXJpYWxpemVyKG9wdGlvbnMucGFyYW1zLnF1ZXJ5ID8/IHt9KTtcbiAgaWYgKHNlYXJjaC5zdGFydHNXaXRoKFwiP1wiKSkge1xuICAgIHNlYXJjaCA9IHNlYXJjaC5zdWJzdHJpbmcoMSk7XG4gIH1cbiAgaWYgKHNlYXJjaCkge1xuICAgIGZpbmFsVVJMICs9IGA/JHtzZWFyY2h9YDtcbiAgfVxuICByZXR1cm4gZmluYWxVUkw7XG59XG5mdW5jdGlvbiBtZXJnZUhlYWRlcnMoLi4uYWxsSGVhZGVycykge1xuICBjb25zdCBmaW5hbEhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICBmb3IgKGNvbnN0IGggb2YgYWxsSGVhZGVycykge1xuICAgIGlmICghaCB8fCB0eXBlb2YgaCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGl0ZXJhdG9yID0gaCBpbnN0YW5jZW9mIEhlYWRlcnMgPyBoLmVudHJpZXMoKSA6IE9iamVjdC5lbnRyaWVzKGgpO1xuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIGl0ZXJhdG9yKSB7XG4gICAgICBpZiAodiA9PT0gbnVsbCkge1xuICAgICAgICBmaW5hbEhlYWRlcnMuZGVsZXRlKGspO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdjIgb2Ygdikge1xuICAgICAgICAgIGZpbmFsSGVhZGVycy5hcHBlbmQoaywgdjIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHYgIT09IHZvaWQgMCkge1xuICAgICAgICBmaW5hbEhlYWRlcnMuc2V0KGssIHYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmluYWxIZWFkZXJzO1xufVxuZnVuY3Rpb24gcmVtb3ZlVHJhaWxpbmdTbGFzaCh1cmwpIHtcbiAgaWYgKHVybC5lbmRzV2l0aChcIi9cIikpIHtcbiAgICByZXR1cm4gdXJsLnN1YnN0cmluZygwLCB1cmwubGVuZ3RoIC0gMSk7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/openapi-fetch/dist/cjs/index.cjs\n");

/***/ })

};
;