"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slow-redact";
exports.ids = ["vendor-chunks/slow-redact"];
exports.modules = {

/***/ "(ssr)/./node_modules/slow-redact/index.js":
/*!*******************************************!*\
  !*** ./node_modules/slow-redact/index.js ***!
  \*******************************************/
/***/ ((module) => {

eval("\n\nfunction deepClone (obj) {\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  if (obj instanceof Date) {\n    return new Date(obj.getTime())\n  }\n\n  if (obj instanceof Array) {\n    const cloned = []\n    for (let i = 0; i < obj.length; i++) {\n      cloned[i] = deepClone(obj[i])\n    }\n    return cloned\n  }\n\n  if (typeof obj === 'object') {\n    const cloned = Object.create(Object.getPrototypeOf(obj))\n    for (const key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        cloned[key] = deepClone(obj[key])\n      }\n    }\n    return cloned\n  }\n\n  return obj\n}\n\nfunction parsePath (path) {\n  const parts = []\n  let current = ''\n  let inBrackets = false\n  let inQuotes = false\n  let quoteChar = ''\n\n  for (let i = 0; i < path.length; i++) {\n    const char = path[i]\n\n    if (!inBrackets && char === '.') {\n      if (current) {\n        parts.push(current)\n        current = ''\n      }\n    } else if (char === '[') {\n      if (current) {\n        parts.push(current)\n        current = ''\n      }\n      inBrackets = true\n    } else if (char === ']' && inBrackets) {\n      // Always push the current value when closing brackets, even if it's an empty string\n      parts.push(current)\n      current = ''\n      inBrackets = false\n      inQuotes = false\n    } else if ((char === '\"' || char === \"'\") && inBrackets) {\n      if (!inQuotes) {\n        inQuotes = true\n        quoteChar = char\n      } else if (char === quoteChar) {\n        inQuotes = false\n        quoteChar = ''\n      } else {\n        current += char\n      }\n    } else {\n      current += char\n    }\n  }\n\n  if (current) {\n    parts.push(current)\n  }\n\n  return parts\n}\n\nfunction setValue (obj, parts, value) {\n  let current = obj\n\n  for (let i = 0; i < parts.length - 1; i++) {\n    const key = parts[i]\n    // Type safety: Check if current is an object before using 'in' operator\n    if (typeof current !== 'object' || current === null || !(key in current)) {\n      return false // Path doesn't exist, don't create it\n    }\n    if (typeof current[key] !== 'object' || current[key] === null) {\n      return false // Path doesn't exist properly\n    }\n    current = current[key]\n  }\n\n  const lastKey = parts[parts.length - 1]\n  if (lastKey === '*') {\n    if (Array.isArray(current)) {\n      for (let i = 0; i < current.length; i++) {\n        current[i] = value\n      }\n    } else if (typeof current === 'object' && current !== null) {\n      for (const key in current) {\n        if (Object.prototype.hasOwnProperty.call(current, key)) {\n          current[key] = value\n        }\n      }\n    }\n  } else {\n    // Type safety: Check if current is an object before using 'in' operator\n    if (typeof current === 'object' && current !== null && lastKey in current && Object.prototype.hasOwnProperty.call(current, lastKey)) {\n      current[lastKey] = value\n    }\n  }\n  return true\n}\n\nfunction removeKey (obj, parts) {\n  let current = obj\n\n  for (let i = 0; i < parts.length - 1; i++) {\n    const key = parts[i]\n    // Type safety: Check if current is an object before using 'in' operator\n    if (typeof current !== 'object' || current === null || !(key in current)) {\n      return false // Path doesn't exist, don't create it\n    }\n    if (typeof current[key] !== 'object' || current[key] === null) {\n      return false // Path doesn't exist properly\n    }\n    current = current[key]\n  }\n\n  const lastKey = parts[parts.length - 1]\n  if (lastKey === '*') {\n    if (Array.isArray(current)) {\n      // For arrays, we can't really \"remove\" all items as that would change indices\n      // Instead, we set them to undefined which will be omitted by JSON.stringify\n      for (let i = 0; i < current.length; i++) {\n        current[i] = undefined\n      }\n    } else if (typeof current === 'object' && current !== null) {\n      for (const key in current) {\n        if (Object.prototype.hasOwnProperty.call(current, key)) {\n          delete current[key]\n        }\n      }\n    }\n  } else {\n    // Type safety: Check if current is an object before using 'in' operator\n    if (typeof current === 'object' && current !== null && lastKey in current && Object.prototype.hasOwnProperty.call(current, lastKey)) {\n      delete current[lastKey]\n    }\n  }\n  return true\n}\n\n// Sentinel object to distinguish between undefined value and non-existent path\nconst PATH_NOT_FOUND = Symbol('PATH_NOT_FOUND')\n\nfunction getValueIfExists (obj, parts) {\n  let current = obj\n\n  for (const part of parts) {\n    if (current === null || current === undefined) {\n      return PATH_NOT_FOUND\n    }\n    // Type safety: Check if current is an object before property access\n    if (typeof current !== 'object' || current === null) {\n      return PATH_NOT_FOUND\n    }\n    // Check if the property exists before accessing it\n    if (!(part in current)) {\n      return PATH_NOT_FOUND\n    }\n    current = current[part]\n  }\n\n  return current\n}\n\nfunction getValue (obj, parts) {\n  let current = obj\n\n  for (const part of parts) {\n    if (current === null || current === undefined) {\n      return undefined\n    }\n    // Type safety: Check if current is an object before property access\n    if (typeof current !== 'object' || current === null) {\n      return undefined\n    }\n    current = current[part]\n  }\n\n  return current\n}\n\nfunction redactPaths (obj, paths, censor, remove = false) {\n  for (const path of paths) {\n    const parts = parsePath(path)\n\n    if (parts.includes('*')) {\n      redactWildcardPath(obj, parts, censor, path, remove)\n    } else {\n      if (remove) {\n        removeKey(obj, parts)\n      } else {\n        // Get value only if path exists - single traversal\n        const value = getValueIfExists(obj, parts)\n        if (value === PATH_NOT_FOUND) {\n          continue\n        }\n\n        const actualCensor = typeof censor === 'function'\n          ? censor(value, parts)\n          : censor\n        setValue(obj, parts, actualCensor)\n      }\n    }\n  }\n}\n\nfunction redactWildcardPath (obj, parts, censor, originalPath, remove = false) {\n  const wildcardIndex = parts.indexOf('*')\n\n  if (wildcardIndex === parts.length - 1) {\n    const parentParts = parts.slice(0, -1)\n    let current = obj\n\n    for (const part of parentParts) {\n      if (current === null || current === undefined) return\n      // Type safety: Check if current is an object before property access\n      if (typeof current !== 'object' || current === null) return\n      current = current[part]\n    }\n\n    if (Array.isArray(current)) {\n      if (remove) {\n        // For arrays, set all items to undefined which will be omitted by JSON.stringify\n        for (let i = 0; i < current.length; i++) {\n          current[i] = undefined\n        }\n      } else {\n        for (let i = 0; i < current.length; i++) {\n          const indexPath = [...parentParts, i.toString()]\n          const actualCensor = typeof censor === 'function'\n            ? censor(current[i], indexPath)\n            : censor\n          current[i] = actualCensor\n        }\n      }\n    } else if (typeof current === 'object' && current !== null) {\n      if (remove) {\n        // Collect keys to delete to avoid issues with deleting during iteration\n        const keysToDelete = []\n        for (const key in current) {\n          if (Object.prototype.hasOwnProperty.call(current, key)) {\n            keysToDelete.push(key)\n          }\n        }\n        for (const key of keysToDelete) {\n          delete current[key]\n        }\n      } else {\n        for (const key in current) {\n          const keyPath = [...parentParts, key]\n          const actualCensor = typeof censor === 'function'\n            ? censor(current[key], keyPath)\n            : censor\n          current[key] = actualCensor\n        }\n      }\n    }\n  } else {\n    redactIntermediateWildcard(obj, parts, censor, wildcardIndex, originalPath, remove)\n  }\n}\n\nfunction redactIntermediateWildcard (obj, parts, censor, wildcardIndex, originalPath, remove = false) {\n  const beforeWildcard = parts.slice(0, wildcardIndex)\n  const afterWildcard = parts.slice(wildcardIndex + 1)\n  const pathArray = [] // Cached array to avoid allocations\n\n  function traverse (current, pathLength) {\n    if (pathLength === beforeWildcard.length) {\n      if (Array.isArray(current)) {\n        for (let i = 0; i < current.length; i++) {\n          pathArray[pathLength] = i.toString()\n          traverse(current[i], pathLength + 1)\n        }\n      } else if (typeof current === 'object' && current !== null) {\n        for (const key in current) {\n          pathArray[pathLength] = key\n          traverse(current[key], pathLength + 1)\n        }\n      }\n    } else if (pathLength < beforeWildcard.length) {\n      const nextKey = beforeWildcard[pathLength]\n      // Type safety: Check if current is an object before using 'in' operator\n      if (current && typeof current === 'object' && current !== null && nextKey in current) {\n        pathArray[pathLength] = nextKey\n        traverse(current[nextKey], pathLength + 1)\n      }\n    } else {\n      // Check if afterWildcard contains more wildcards\n      if (afterWildcard.includes('*')) {\n        // Recursively handle remaining wildcards\n        // Wrap censor to prepend current path context\n        const wrappedCensor = typeof censor === 'function'\n          ? (value, path) => {\n              const fullPath = [...pathArray.slice(0, pathLength), ...path]\n              return censor(value, fullPath)\n            }\n          : censor\n        redactWildcardPath(current, afterWildcard, wrappedCensor, originalPath, remove)\n      } else {\n        // No more wildcards, apply the redaction directly\n        if (remove) {\n          removeKey(current, afterWildcard)\n        } else {\n          const actualCensor = typeof censor === 'function'\n            ? censor(getValue(current, afterWildcard), [...pathArray.slice(0, pathLength), ...afterWildcard])\n            : censor\n          setValue(current, afterWildcard, actualCensor)\n        }\n      }\n    }\n  }\n\n  if (beforeWildcard.length === 0) {\n    traverse(obj, 0)\n  } else {\n    let current = obj\n    for (let i = 0; i < beforeWildcard.length; i++) {\n      const part = beforeWildcard[i]\n      if (current === null || current === undefined) return\n      // Type safety: Check if current is an object before property access\n      if (typeof current !== 'object' || current === null) return\n      current = current[part]\n      pathArray[i] = part\n    }\n    if (current !== null && current !== undefined) {\n      traverse(current, beforeWildcard.length)\n    }\n  }\n}\n\nfunction buildPathStructure (pathsToClone) {\n  if (pathsToClone.length === 0) {\n    return null // No paths to redact\n  }\n\n  // Parse all paths and organize by depth\n  const pathStructure = new Map()\n  for (const path of pathsToClone) {\n    const parts = parsePath(path)\n    let current = pathStructure\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i]\n      if (!current.has(part)) {\n        current.set(part, new Map())\n      }\n      current = current.get(part)\n    }\n  }\n  return pathStructure\n}\n\nfunction selectiveClone (obj, pathStructure) {\n  if (!pathStructure) {\n    return obj // No paths to redact, return original\n  }\n\n  function cloneSelectively (source, pathMap, depth = 0) {\n    if (!pathMap || pathMap.size === 0) {\n      return source // No more paths to clone, return reference\n    }\n\n    if (source === null || typeof source !== 'object') {\n      return source\n    }\n\n    if (source instanceof Date) {\n      return new Date(source.getTime())\n    }\n\n    if (Array.isArray(source)) {\n      const cloned = []\n      for (let i = 0; i < source.length; i++) {\n        const indexStr = i.toString()\n        if (pathMap.has(indexStr) || pathMap.has('*')) {\n          cloned[i] = cloneSelectively(source[i], pathMap.get(indexStr) || pathMap.get('*'))\n        } else {\n          cloned[i] = source[i] // Share reference for non-redacted items\n        }\n      }\n      return cloned\n    }\n\n    // Handle objects\n    const cloned = Object.create(Object.getPrototypeOf(source))\n    for (const key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        if (pathMap.has(key) || pathMap.has('*')) {\n          cloned[key] = cloneSelectively(source[key], pathMap.get(key) || pathMap.get('*'))\n        } else {\n          cloned[key] = source[key] // Share reference for non-redacted properties\n        }\n      }\n    }\n    return cloned\n  }\n\n  return cloneSelectively(obj, pathStructure)\n}\n\nfunction validatePath (path) {\n  if (typeof path !== 'string') {\n    throw new Error('Paths must be (non-empty) strings')\n  }\n\n  if (path === '') {\n    throw new Error('Invalid redaction path ()')\n  }\n\n  // Check for double dots\n  if (path.includes('..')) {\n    throw new Error(`Invalid redaction path (${path})`)\n  }\n\n  // Check for comma-separated paths (invalid syntax)\n  if (path.includes(',')) {\n    throw new Error(`Invalid redaction path (${path})`)\n  }\n\n  // Check for unmatched brackets\n  let bracketCount = 0\n  let inQuotes = false\n  let quoteChar = ''\n\n  for (let i = 0; i < path.length; i++) {\n    const char = path[i]\n\n    if ((char === '\"' || char === \"'\") && bracketCount > 0) {\n      if (!inQuotes) {\n        inQuotes = true\n        quoteChar = char\n      } else if (char === quoteChar) {\n        inQuotes = false\n        quoteChar = ''\n      }\n    } else if (char === '[' && !inQuotes) {\n      bracketCount++\n    } else if (char === ']' && !inQuotes) {\n      bracketCount--\n      if (bracketCount < 0) {\n        throw new Error(`Invalid redaction path (${path})`)\n      }\n    }\n  }\n\n  if (bracketCount !== 0) {\n    throw new Error(`Invalid redaction path (${path})`)\n  }\n}\n\nfunction validatePaths (paths) {\n  if (!Array.isArray(paths)) {\n    throw new TypeError('paths must be an array')\n  }\n\n  for (const path of paths) {\n    validatePath(path)\n  }\n}\n\nfunction slowRedact (options = {}) {\n  const {\n    paths = [],\n    censor = '[REDACTED]',\n    serialize = JSON.stringify,\n    strict = true,\n    remove = false\n  } = options\n\n  // Validate paths upfront to match fast-redact behavior\n  validatePaths(paths)\n\n  // Build path structure once during setup, not on every call\n  const pathStructure = buildPathStructure(paths)\n\n  return function redact (obj) {\n    if (strict && (obj === null || typeof obj !== 'object')) {\n      if (obj === null || obj === undefined) {\n        return serialize ? serialize(obj) : obj\n      }\n      if (typeof obj !== 'object') {\n        return serialize ? serialize(obj) : obj\n      }\n    }\n\n    // Only clone paths that need redaction\n    const cloned = selectiveClone(obj, pathStructure)\n    const original = obj // Keep reference to original for restore\n\n    let actualCensor = censor\n    if (typeof censor === 'function') {\n      actualCensor = censor\n    }\n\n    redactPaths(cloned, paths, actualCensor, remove)\n\n    if (serialize === false) {\n      cloned.restore = function () {\n        return deepClone(original) // Full clone only when restore is called\n      }\n      return cloned\n    }\n\n    if (typeof serialize === 'function') {\n      return serialize(cloned)\n    }\n\n    return JSON.stringify(cloned)\n  }\n}\n\nmodule.exports = slowRedact\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2xvdy1yZWRhY3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxLQUFLO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsS0FBSztBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsbURBQW1ELEtBQUs7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLEtBQUs7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NpbHZpcy9Eb2N1bWVudHMvcmV2b2x1Y2FvLWNpYmVybmV0aWNhL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9zbG93LXJlZGFjdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuZnVuY3Rpb24gZGVlcENsb25lIChvYmopIHtcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvYmpcbiAgfVxuXG4gIGlmIChvYmogaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKG9iai5nZXRUaW1lKCkpXG4gIH1cblxuICBpZiAob2JqIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBjb25zdCBjbG9uZWQgPSBbXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjbG9uZWRbaV0gPSBkZWVwQ2xvbmUob2JqW2ldKVxuICAgIH1cbiAgICByZXR1cm4gY2xvbmVkXG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICBjb25zdCBjbG9uZWQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKVxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgY2xvbmVkW2tleV0gPSBkZWVwQ2xvbmUob2JqW2tleV0pXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbG9uZWRcbiAgfVxuXG4gIHJldHVybiBvYmpcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGNvbnN0IHBhcnRzID0gW11cbiAgbGV0IGN1cnJlbnQgPSAnJ1xuICBsZXQgaW5CcmFja2V0cyA9IGZhbHNlXG4gIGxldCBpblF1b3RlcyA9IGZhbHNlXG4gIGxldCBxdW90ZUNoYXIgPSAnJ1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBwYXRoW2ldXG5cbiAgICBpZiAoIWluQnJhY2tldHMgJiYgY2hhciA9PT0gJy4nKSB7XG4gICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICBwYXJ0cy5wdXNoKGN1cnJlbnQpXG4gICAgICAgIGN1cnJlbnQgPSAnJ1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ1snKSB7XG4gICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICBwYXJ0cy5wdXNoKGN1cnJlbnQpXG4gICAgICAgIGN1cnJlbnQgPSAnJ1xuICAgICAgfVxuICAgICAgaW5CcmFja2V0cyA9IHRydWVcbiAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICddJyAmJiBpbkJyYWNrZXRzKSB7XG4gICAgICAvLyBBbHdheXMgcHVzaCB0aGUgY3VycmVudCB2YWx1ZSB3aGVuIGNsb3NpbmcgYnJhY2tldHMsIGV2ZW4gaWYgaXQncyBhbiBlbXB0eSBzdHJpbmdcbiAgICAgIHBhcnRzLnB1c2goY3VycmVudClcbiAgICAgIGN1cnJlbnQgPSAnJ1xuICAgICAgaW5CcmFja2V0cyA9IGZhbHNlXG4gICAgICBpblF1b3RlcyA9IGZhbHNlXG4gICAgfSBlbHNlIGlmICgoY2hhciA9PT0gJ1wiJyB8fCBjaGFyID09PSBcIidcIikgJiYgaW5CcmFja2V0cykge1xuICAgICAgaWYgKCFpblF1b3Rlcykge1xuICAgICAgICBpblF1b3RlcyA9IHRydWVcbiAgICAgICAgcXVvdGVDaGFyID0gY2hhclxuICAgICAgfSBlbHNlIGlmIChjaGFyID09PSBxdW90ZUNoYXIpIHtcbiAgICAgICAgaW5RdW90ZXMgPSBmYWxzZVxuICAgICAgICBxdW90ZUNoYXIgPSAnJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudCArPSBjaGFyXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQgKz0gY2hhclxuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyZW50KSB7XG4gICAgcGFydHMucHVzaChjdXJyZW50KVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzXG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlIChvYmosIHBhcnRzLCB2YWx1ZSkge1xuICBsZXQgY3VycmVudCA9IG9ialxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gcGFydHNbaV1cbiAgICAvLyBUeXBlIHNhZmV0eTogQ2hlY2sgaWYgY3VycmVudCBpcyBhbiBvYmplY3QgYmVmb3JlIHVzaW5nICdpbicgb3BlcmF0b3JcbiAgICBpZiAodHlwZW9mIGN1cnJlbnQgIT09ICdvYmplY3QnIHx8IGN1cnJlbnQgPT09IG51bGwgfHwgIShrZXkgaW4gY3VycmVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZSAvLyBQYXRoIGRvZXNuJ3QgZXhpc3QsIGRvbid0IGNyZWF0ZSBpdFxuICAgIH1cbiAgICBpZiAodHlwZW9mIGN1cnJlbnRba2V5XSAhPT0gJ29iamVjdCcgfHwgY3VycmVudFtrZXldID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2UgLy8gUGF0aCBkb2Vzbid0IGV4aXN0IHByb3Blcmx5XG4gICAgfVxuICAgIGN1cnJlbnQgPSBjdXJyZW50W2tleV1cbiAgfVxuXG4gIGNvbnN0IGxhc3RLZXkgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXVxuICBpZiAobGFzdEtleSA9PT0gJyonKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50W2ldID0gdmFsdWVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjdXJyZW50ID09PSAnb2JqZWN0JyAmJiBjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdXJyZW50KSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3VycmVudCwga2V5KSkge1xuICAgICAgICAgIGN1cnJlbnRba2V5XSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVHlwZSBzYWZldHk6IENoZWNrIGlmIGN1cnJlbnQgaXMgYW4gb2JqZWN0IGJlZm9yZSB1c2luZyAnaW4nIG9wZXJhdG9yXG4gICAgaWYgKHR5cGVvZiBjdXJyZW50ID09PSAnb2JqZWN0JyAmJiBjdXJyZW50ICE9PSBudWxsICYmIGxhc3RLZXkgaW4gY3VycmVudCAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3VycmVudCwgbGFzdEtleSkpIHtcbiAgICAgIGN1cnJlbnRbbGFzdEtleV0gPSB2YWx1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiByZW1vdmVLZXkgKG9iaiwgcGFydHMpIHtcbiAgbGV0IGN1cnJlbnQgPSBvYmpcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IHBhcnRzW2ldXG4gICAgLy8gVHlwZSBzYWZldHk6IENoZWNrIGlmIGN1cnJlbnQgaXMgYW4gb2JqZWN0IGJlZm9yZSB1c2luZyAnaW4nIG9wZXJhdG9yXG4gICAgaWYgKHR5cGVvZiBjdXJyZW50ICE9PSAnb2JqZWN0JyB8fCBjdXJyZW50ID09PSBudWxsIHx8ICEoa2V5IGluIGN1cnJlbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2UgLy8gUGF0aCBkb2Vzbid0IGV4aXN0LCBkb24ndCBjcmVhdGUgaXRcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjdXJyZW50W2tleV0gIT09ICdvYmplY3QnIHx8IGN1cnJlbnRba2V5XSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlIC8vIFBhdGggZG9lc24ndCBleGlzdCBwcm9wZXJseVxuICAgIH1cbiAgICBjdXJyZW50ID0gY3VycmVudFtrZXldXG4gIH1cblxuICBjb25zdCBsYXN0S2V5ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV1cbiAgaWYgKGxhc3RLZXkgPT09ICcqJykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgICAvLyBGb3IgYXJyYXlzLCB3ZSBjYW4ndCByZWFsbHkgXCJyZW1vdmVcIiBhbGwgaXRlbXMgYXMgdGhhdCB3b3VsZCBjaGFuZ2UgaW5kaWNlc1xuICAgICAgLy8gSW5zdGVhZCwgd2Ugc2V0IHRoZW0gdG8gdW5kZWZpbmVkIHdoaWNoIHdpbGwgYmUgb21pdHRlZCBieSBKU09OLnN0cmluZ2lmeVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnRbaV0gPSB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjdXJyZW50ID09PSAnb2JqZWN0JyAmJiBjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdXJyZW50KSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3VycmVudCwga2V5KSkge1xuICAgICAgICAgIGRlbGV0ZSBjdXJyZW50W2tleV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUeXBlIHNhZmV0eTogQ2hlY2sgaWYgY3VycmVudCBpcyBhbiBvYmplY3QgYmVmb3JlIHVzaW5nICdpbicgb3BlcmF0b3JcbiAgICBpZiAodHlwZW9mIGN1cnJlbnQgPT09ICdvYmplY3QnICYmIGN1cnJlbnQgIT09IG51bGwgJiYgbGFzdEtleSBpbiBjdXJyZW50ICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjdXJyZW50LCBsYXN0S2V5KSkge1xuICAgICAgZGVsZXRlIGN1cnJlbnRbbGFzdEtleV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gU2VudGluZWwgb2JqZWN0IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gdW5kZWZpbmVkIHZhbHVlIGFuZCBub24tZXhpc3RlbnQgcGF0aFxuY29uc3QgUEFUSF9OT1RfRk9VTkQgPSBTeW1ib2woJ1BBVEhfTk9UX0ZPVU5EJylcblxuZnVuY3Rpb24gZ2V0VmFsdWVJZkV4aXN0cyAob2JqLCBwYXJ0cykge1xuICBsZXQgY3VycmVudCA9IG9ialxuXG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIFBBVEhfTk9UX0ZPVU5EXG4gICAgfVxuICAgIC8vIFR5cGUgc2FmZXR5OiBDaGVjayBpZiBjdXJyZW50IGlzIGFuIG9iamVjdCBiZWZvcmUgcHJvcGVydHkgYWNjZXNzXG4gICAgaWYgKHR5cGVvZiBjdXJyZW50ICE9PSAnb2JqZWN0JyB8fCBjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gUEFUSF9OT1RfRk9VTkRcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHByb3BlcnR5IGV4aXN0cyBiZWZvcmUgYWNjZXNzaW5nIGl0XG4gICAgaWYgKCEocGFydCBpbiBjdXJyZW50KSkge1xuICAgICAgcmV0dXJuIFBBVEhfTk9UX0ZPVU5EXG4gICAgfVxuICAgIGN1cnJlbnQgPSBjdXJyZW50W3BhcnRdXG4gIH1cblxuICByZXR1cm4gY3VycmVudFxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob2JqLCBwYXJ0cykge1xuICBsZXQgY3VycmVudCA9IG9ialxuXG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgICAvLyBUeXBlIHNhZmV0eTogQ2hlY2sgaWYgY3VycmVudCBpcyBhbiBvYmplY3QgYmVmb3JlIHByb3BlcnR5IGFjY2Vzc1xuICAgIGlmICh0eXBlb2YgY3VycmVudCAhPT0gJ29iamVjdCcgfHwgY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgICBjdXJyZW50ID0gY3VycmVudFtwYXJ0XVxuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnRcbn1cblxuZnVuY3Rpb24gcmVkYWN0UGF0aHMgKG9iaiwgcGF0aHMsIGNlbnNvciwgcmVtb3ZlID0gZmFsc2UpIHtcbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgY29uc3QgcGFydHMgPSBwYXJzZVBhdGgocGF0aClcblxuICAgIGlmIChwYXJ0cy5pbmNsdWRlcygnKicpKSB7XG4gICAgICByZWRhY3RXaWxkY2FyZFBhdGgob2JqLCBwYXJ0cywgY2Vuc29yLCBwYXRoLCByZW1vdmUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgcmVtb3ZlS2V5KG9iaiwgcGFydHMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBHZXQgdmFsdWUgb25seSBpZiBwYXRoIGV4aXN0cyAtIHNpbmdsZSB0cmF2ZXJzYWxcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRWYWx1ZUlmRXhpc3RzKG9iaiwgcGFydHMpXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gUEFUSF9OT1RfRk9VTkQpIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWN0dWFsQ2Vuc29yID0gdHlwZW9mIGNlbnNvciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gY2Vuc29yKHZhbHVlLCBwYXJ0cylcbiAgICAgICAgICA6IGNlbnNvclxuICAgICAgICBzZXRWYWx1ZShvYmosIHBhcnRzLCBhY3R1YWxDZW5zb3IpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlZGFjdFdpbGRjYXJkUGF0aCAob2JqLCBwYXJ0cywgY2Vuc29yLCBvcmlnaW5hbFBhdGgsIHJlbW92ZSA9IGZhbHNlKSB7XG4gIGNvbnN0IHdpbGRjYXJkSW5kZXggPSBwYXJ0cy5pbmRleE9mKCcqJylcblxuICBpZiAod2lsZGNhcmRJbmRleCA9PT0gcGFydHMubGVuZ3RoIC0gMSkge1xuICAgIGNvbnN0IHBhcmVudFBhcnRzID0gcGFydHMuc2xpY2UoMCwgLTEpXG4gICAgbGV0IGN1cnJlbnQgPSBvYmpcblxuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJlbnRQYXJ0cykge1xuICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudCA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgICAgIC8vIFR5cGUgc2FmZXR5OiBDaGVjayBpZiBjdXJyZW50IGlzIGFuIG9iamVjdCBiZWZvcmUgcHJvcGVydHkgYWNjZXNzXG4gICAgICBpZiAodHlwZW9mIGN1cnJlbnQgIT09ICdvYmplY3QnIHx8IGN1cnJlbnQgPT09IG51bGwpIHJldHVyblxuICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGFydF1cbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xuICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICAvLyBGb3IgYXJyYXlzLCBzZXQgYWxsIGl0ZW1zIHRvIHVuZGVmaW5lZCB3aGljaCB3aWxsIGJlIG9taXR0ZWQgYnkgSlNPTi5zdHJpbmdpZnlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY3VycmVudFtpXSA9IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBpbmRleFBhdGggPSBbLi4ucGFyZW50UGFydHMsIGkudG9TdHJpbmcoKV1cbiAgICAgICAgICBjb25zdCBhY3R1YWxDZW5zb3IgPSB0eXBlb2YgY2Vuc29yID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGNlbnNvcihjdXJyZW50W2ldLCBpbmRleFBhdGgpXG4gICAgICAgICAgICA6IGNlbnNvclxuICAgICAgICAgIGN1cnJlbnRbaV0gPSBhY3R1YWxDZW5zb3JcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGN1cnJlbnQgPT09ICdvYmplY3QnICYmIGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgLy8gQ29sbGVjdCBrZXlzIHRvIGRlbGV0ZSB0byBhdm9pZCBpc3N1ZXMgd2l0aCBkZWxldGluZyBkdXJpbmcgaXRlcmF0aW9uXG4gICAgICAgIGNvbnN0IGtleXNUb0RlbGV0ZSA9IFtdXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN1cnJlbnQpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnJlbnQsIGtleSkpIHtcbiAgICAgICAgICAgIGtleXNUb0RlbGV0ZS5wdXNoKGtleSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5c1RvRGVsZXRlKSB7XG4gICAgICAgICAgZGVsZXRlIGN1cnJlbnRba2V5XVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdXJyZW50KSB7XG4gICAgICAgICAgY29uc3Qga2V5UGF0aCA9IFsuLi5wYXJlbnRQYXJ0cywga2V5XVxuICAgICAgICAgIGNvbnN0IGFjdHVhbENlbnNvciA9IHR5cGVvZiBjZW5zb3IgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gY2Vuc29yKGN1cnJlbnRba2V5XSwga2V5UGF0aClcbiAgICAgICAgICAgIDogY2Vuc29yXG4gICAgICAgICAgY3VycmVudFtrZXldID0gYWN0dWFsQ2Vuc29yXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVkYWN0SW50ZXJtZWRpYXRlV2lsZGNhcmQob2JqLCBwYXJ0cywgY2Vuc29yLCB3aWxkY2FyZEluZGV4LCBvcmlnaW5hbFBhdGgsIHJlbW92ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiByZWRhY3RJbnRlcm1lZGlhdGVXaWxkY2FyZCAob2JqLCBwYXJ0cywgY2Vuc29yLCB3aWxkY2FyZEluZGV4LCBvcmlnaW5hbFBhdGgsIHJlbW92ZSA9IGZhbHNlKSB7XG4gIGNvbnN0IGJlZm9yZVdpbGRjYXJkID0gcGFydHMuc2xpY2UoMCwgd2lsZGNhcmRJbmRleClcbiAgY29uc3QgYWZ0ZXJXaWxkY2FyZCA9IHBhcnRzLnNsaWNlKHdpbGRjYXJkSW5kZXggKyAxKVxuICBjb25zdCBwYXRoQXJyYXkgPSBbXSAvLyBDYWNoZWQgYXJyYXkgdG8gYXZvaWQgYWxsb2NhdGlvbnNcblxuICBmdW5jdGlvbiB0cmF2ZXJzZSAoY3VycmVudCwgcGF0aExlbmd0aCkge1xuICAgIGlmIChwYXRoTGVuZ3RoID09PSBiZWZvcmVXaWxkY2FyZC5sZW5ndGgpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHBhdGhBcnJheVtwYXRoTGVuZ3RoXSA9IGkudG9TdHJpbmcoKVxuICAgICAgICAgIHRyYXZlcnNlKGN1cnJlbnRbaV0sIHBhdGhMZW5ndGggKyAxKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjdXJyZW50ID09PSAnb2JqZWN0JyAmJiBjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN1cnJlbnQpIHtcbiAgICAgICAgICBwYXRoQXJyYXlbcGF0aExlbmd0aF0gPSBrZXlcbiAgICAgICAgICB0cmF2ZXJzZShjdXJyZW50W2tleV0sIHBhdGhMZW5ndGggKyAxKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXRoTGVuZ3RoIDwgYmVmb3JlV2lsZGNhcmQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBuZXh0S2V5ID0gYmVmb3JlV2lsZGNhcmRbcGF0aExlbmd0aF1cbiAgICAgIC8vIFR5cGUgc2FmZXR5OiBDaGVjayBpZiBjdXJyZW50IGlzIGFuIG9iamVjdCBiZWZvcmUgdXNpbmcgJ2luJyBvcGVyYXRvclxuICAgICAgaWYgKGN1cnJlbnQgJiYgdHlwZW9mIGN1cnJlbnQgPT09ICdvYmplY3QnICYmIGN1cnJlbnQgIT09IG51bGwgJiYgbmV4dEtleSBpbiBjdXJyZW50KSB7XG4gICAgICAgIHBhdGhBcnJheVtwYXRoTGVuZ3RoXSA9IG5leHRLZXlcbiAgICAgICAgdHJhdmVyc2UoY3VycmVudFtuZXh0S2V5XSwgcGF0aExlbmd0aCArIDEpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENoZWNrIGlmIGFmdGVyV2lsZGNhcmQgY29udGFpbnMgbW9yZSB3aWxkY2FyZHNcbiAgICAgIGlmIChhZnRlcldpbGRjYXJkLmluY2x1ZGVzKCcqJykpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgaGFuZGxlIHJlbWFpbmluZyB3aWxkY2FyZHNcbiAgICAgICAgLy8gV3JhcCBjZW5zb3IgdG8gcHJlcGVuZCBjdXJyZW50IHBhdGggY29udGV4dFxuICAgICAgICBjb25zdCB3cmFwcGVkQ2Vuc29yID0gdHlwZW9mIGNlbnNvciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gKHZhbHVlLCBwYXRoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gWy4uLnBhdGhBcnJheS5zbGljZSgwLCBwYXRoTGVuZ3RoKSwgLi4ucGF0aF1cbiAgICAgICAgICAgICAgcmV0dXJuIGNlbnNvcih2YWx1ZSwgZnVsbFBhdGgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiBjZW5zb3JcbiAgICAgICAgcmVkYWN0V2lsZGNhcmRQYXRoKGN1cnJlbnQsIGFmdGVyV2lsZGNhcmQsIHdyYXBwZWRDZW5zb3IsIG9yaWdpbmFsUGF0aCwgcmVtb3ZlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8gbW9yZSB3aWxkY2FyZHMsIGFwcGx5IHRoZSByZWRhY3Rpb24gZGlyZWN0bHlcbiAgICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICAgIHJlbW92ZUtleShjdXJyZW50LCBhZnRlcldpbGRjYXJkKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGFjdHVhbENlbnNvciA9IHR5cGVvZiBjZW5zb3IgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gY2Vuc29yKGdldFZhbHVlKGN1cnJlbnQsIGFmdGVyV2lsZGNhcmQpLCBbLi4ucGF0aEFycmF5LnNsaWNlKDAsIHBhdGhMZW5ndGgpLCAuLi5hZnRlcldpbGRjYXJkXSlcbiAgICAgICAgICAgIDogY2Vuc29yXG4gICAgICAgICAgc2V0VmFsdWUoY3VycmVudCwgYWZ0ZXJXaWxkY2FyZCwgYWN0dWFsQ2Vuc29yKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGJlZm9yZVdpbGRjYXJkLmxlbmd0aCA9PT0gMCkge1xuICAgIHRyYXZlcnNlKG9iaiwgMClcbiAgfSBlbHNlIHtcbiAgICBsZXQgY3VycmVudCA9IG9ialxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmVmb3JlV2lsZGNhcmQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnQgPSBiZWZvcmVXaWxkY2FyZFtpXVxuICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudCA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgICAgIC8vIFR5cGUgc2FmZXR5OiBDaGVjayBpZiBjdXJyZW50IGlzIGFuIG9iamVjdCBiZWZvcmUgcHJvcGVydHkgYWNjZXNzXG4gICAgICBpZiAodHlwZW9mIGN1cnJlbnQgIT09ICdvYmplY3QnIHx8IGN1cnJlbnQgPT09IG51bGwpIHJldHVyblxuICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGFydF1cbiAgICAgIHBhdGhBcnJheVtpXSA9IHBhcnRcbiAgICB9XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0cmF2ZXJzZShjdXJyZW50LCBiZWZvcmVXaWxkY2FyZC5sZW5ndGgpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUGF0aFN0cnVjdHVyZSAocGF0aHNUb0Nsb25lKSB7XG4gIGlmIChwYXRoc1RvQ2xvbmUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGwgLy8gTm8gcGF0aHMgdG8gcmVkYWN0XG4gIH1cblxuICAvLyBQYXJzZSBhbGwgcGF0aHMgYW5kIG9yZ2FuaXplIGJ5IGRlcHRoXG4gIGNvbnN0IHBhdGhTdHJ1Y3R1cmUgPSBuZXcgTWFwKClcbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzVG9DbG9uZSkge1xuICAgIGNvbnN0IHBhcnRzID0gcGFyc2VQYXRoKHBhdGgpXG4gICAgbGV0IGN1cnJlbnQgPSBwYXRoU3RydWN0dXJlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2ldXG4gICAgICBpZiAoIWN1cnJlbnQuaGFzKHBhcnQpKSB7XG4gICAgICAgIGN1cnJlbnQuc2V0KHBhcnQsIG5ldyBNYXAoKSlcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmdldChwYXJ0KVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0aFN0cnVjdHVyZVxufVxuXG5mdW5jdGlvbiBzZWxlY3RpdmVDbG9uZSAob2JqLCBwYXRoU3RydWN0dXJlKSB7XG4gIGlmICghcGF0aFN0cnVjdHVyZSkge1xuICAgIHJldHVybiBvYmogLy8gTm8gcGF0aHMgdG8gcmVkYWN0LCByZXR1cm4gb3JpZ2luYWxcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb25lU2VsZWN0aXZlbHkgKHNvdXJjZSwgcGF0aE1hcCwgZGVwdGggPSAwKSB7XG4gICAgaWYgKCFwYXRoTWFwIHx8IHBhdGhNYXAuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHNvdXJjZSAvLyBObyBtb3JlIHBhdGhzIHRvIGNsb25lLCByZXR1cm4gcmVmZXJlbmNlXG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZSA9PT0gbnVsbCB8fCB0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHNvdXJjZVxuICAgIH1cblxuICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoc291cmNlLmdldFRpbWUoKSlcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICBjb25zdCBjbG9uZWQgPSBbXVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaW5kZXhTdHIgPSBpLnRvU3RyaW5nKClcbiAgICAgICAgaWYgKHBhdGhNYXAuaGFzKGluZGV4U3RyKSB8fCBwYXRoTWFwLmhhcygnKicpKSB7XG4gICAgICAgICAgY2xvbmVkW2ldID0gY2xvbmVTZWxlY3RpdmVseShzb3VyY2VbaV0sIHBhdGhNYXAuZ2V0KGluZGV4U3RyKSB8fCBwYXRoTWFwLmdldCgnKicpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb25lZFtpXSA9IHNvdXJjZVtpXSAvLyBTaGFyZSByZWZlcmVuY2UgZm9yIG5vbi1yZWRhY3RlZCBpdGVtc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvbmVkXG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIG9iamVjdHNcbiAgICBjb25zdCBjbG9uZWQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihzb3VyY2UpKVxuICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgaWYgKHBhdGhNYXAuaGFzKGtleSkgfHwgcGF0aE1hcC5oYXMoJyonKSkge1xuICAgICAgICAgIGNsb25lZFtrZXldID0gY2xvbmVTZWxlY3RpdmVseShzb3VyY2Vba2V5XSwgcGF0aE1hcC5nZXQoa2V5KSB8fCBwYXRoTWFwLmdldCgnKicpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb25lZFtrZXldID0gc291cmNlW2tleV0gLy8gU2hhcmUgcmVmZXJlbmNlIGZvciBub24tcmVkYWN0ZWQgcHJvcGVydGllc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbG9uZWRcbiAgfVxuXG4gIHJldHVybiBjbG9uZVNlbGVjdGl2ZWx5KG9iaiwgcGF0aFN0cnVjdHVyZSlcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQYXRoIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGhzIG11c3QgYmUgKG5vbi1lbXB0eSkgc3RyaW5ncycpXG4gIH1cblxuICBpZiAocGF0aCA9PT0gJycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVkYWN0aW9uIHBhdGggKCknKVxuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGRvdWJsZSBkb3RzXG4gIGlmIChwYXRoLmluY2x1ZGVzKCcuLicpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJlZGFjdGlvbiBwYXRoICgke3BhdGh9KWApXG4gIH1cblxuICAvLyBDaGVjayBmb3IgY29tbWEtc2VwYXJhdGVkIHBhdGhzIChpbnZhbGlkIHN5bnRheClcbiAgaWYgKHBhdGguaW5jbHVkZXMoJywnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByZWRhY3Rpb24gcGF0aCAoJHtwYXRofSlgKVxuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIHVubWF0Y2hlZCBicmFja2V0c1xuICBsZXQgYnJhY2tldENvdW50ID0gMFxuICBsZXQgaW5RdW90ZXMgPSBmYWxzZVxuICBsZXQgcXVvdGVDaGFyID0gJydcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gcGF0aFtpXVxuXG4gICAgaWYgKChjaGFyID09PSAnXCInIHx8IGNoYXIgPT09IFwiJ1wiKSAmJiBicmFja2V0Q291bnQgPiAwKSB7XG4gICAgICBpZiAoIWluUXVvdGVzKSB7XG4gICAgICAgIGluUXVvdGVzID0gdHJ1ZVxuICAgICAgICBxdW90ZUNoYXIgPSBjaGFyXG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPT09IHF1b3RlQ2hhcikge1xuICAgICAgICBpblF1b3RlcyA9IGZhbHNlXG4gICAgICAgIHF1b3RlQ2hhciA9ICcnXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaGFyID09PSAnWycgJiYgIWluUXVvdGVzKSB7XG4gICAgICBicmFja2V0Q291bnQrK1xuICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ10nICYmICFpblF1b3Rlcykge1xuICAgICAgYnJhY2tldENvdW50LS1cbiAgICAgIGlmIChicmFja2V0Q291bnQgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByZWRhY3Rpb24gcGF0aCAoJHtwYXRofSlgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChicmFja2V0Q291bnQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmVkYWN0aW9uIHBhdGggKCR7cGF0aH0pYClcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVBhdGhzIChwYXRocykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aHMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0aHMgbXVzdCBiZSBhbiBhcnJheScpXG4gIH1cblxuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICB2YWxpZGF0ZVBhdGgocGF0aClcbiAgfVxufVxuXG5mdW5jdGlvbiBzbG93UmVkYWN0IChvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHBhdGhzID0gW10sXG4gICAgY2Vuc29yID0gJ1tSRURBQ1RFRF0nLFxuICAgIHNlcmlhbGl6ZSA9IEpTT04uc3RyaW5naWZ5LFxuICAgIHN0cmljdCA9IHRydWUsXG4gICAgcmVtb3ZlID0gZmFsc2VcbiAgfSA9IG9wdGlvbnNcblxuICAvLyBWYWxpZGF0ZSBwYXRocyB1cGZyb250IHRvIG1hdGNoIGZhc3QtcmVkYWN0IGJlaGF2aW9yXG4gIHZhbGlkYXRlUGF0aHMocGF0aHMpXG5cbiAgLy8gQnVpbGQgcGF0aCBzdHJ1Y3R1cmUgb25jZSBkdXJpbmcgc2V0dXAsIG5vdCBvbiBldmVyeSBjYWxsXG4gIGNvbnN0IHBhdGhTdHJ1Y3R1cmUgPSBidWlsZFBhdGhTdHJ1Y3R1cmUocGF0aHMpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHJlZGFjdCAob2JqKSB7XG4gICAgaWYgKHN0cmljdCAmJiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSkge1xuICAgICAgaWYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplID8gc2VyaWFsaXplKG9iaikgOiBvYmpcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplID8gc2VyaWFsaXplKG9iaikgOiBvYmpcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPbmx5IGNsb25lIHBhdGhzIHRoYXQgbmVlZCByZWRhY3Rpb25cbiAgICBjb25zdCBjbG9uZWQgPSBzZWxlY3RpdmVDbG9uZShvYmosIHBhdGhTdHJ1Y3R1cmUpXG4gICAgY29uc3Qgb3JpZ2luYWwgPSBvYmogLy8gS2VlcCByZWZlcmVuY2UgdG8gb3JpZ2luYWwgZm9yIHJlc3RvcmVcblxuICAgIGxldCBhY3R1YWxDZW5zb3IgPSBjZW5zb3JcbiAgICBpZiAodHlwZW9mIGNlbnNvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYWN0dWFsQ2Vuc29yID0gY2Vuc29yXG4gICAgfVxuXG4gICAgcmVkYWN0UGF0aHMoY2xvbmVkLCBwYXRocywgYWN0dWFsQ2Vuc29yLCByZW1vdmUpXG5cbiAgICBpZiAoc2VyaWFsaXplID09PSBmYWxzZSkge1xuICAgICAgY2xvbmVkLnJlc3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkZWVwQ2xvbmUob3JpZ2luYWwpIC8vIEZ1bGwgY2xvbmUgb25seSB3aGVuIHJlc3RvcmUgaXMgY2FsbGVkXG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvbmVkXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzZXJpYWxpemUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBzZXJpYWxpemUoY2xvbmVkKVxuICAgIH1cblxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShjbG9uZWQpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzbG93UmVkYWN0XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/slow-redact/index.js\n");

/***/ })

};
;