{"version":3,"sources":["turbopack:///[project]/node_modules/node-gyp-build/node-gyp-build.js","turbopack:///[project]/node_modules/node-gyp-build/index.js","turbopack:///[project]/node_modules/bufferutil/fallback.js","turbopack:///[project]/node_modules/bufferutil/index.js","turbopack:///[project]/node_modules/utf-8-validate/fallback.js","turbopack:///[project]/node_modules/utf-8-validate/index.js","turbopack:///[project]/node_modules/idb-keyval/dist/index.js","turbopack:///[project]/node_modules/@walletconnect/ethereum-provider/src/constants/values.ts","turbopack:///[project]/node_modules/@walletconnect/ethereum-provider/src/constants/rpc.ts","turbopack:///[project]/node_modules/@walletconnect/ethereum-provider/src/utils/appkit.ts","turbopack:///[project]/node_modules/@walletconnect/ethereum-provider/src/EthereumProvider.ts","turbopack:///[project]/node_modules/@walletconnect/ethereum-provider/src/index.ts","turbopack:///[project]/node_modules/@walletconnect/ethereum-provider/src/wcmToAppKit.ts"],"sourcesContent":["var fs = require('fs')\nvar path = require('path')\nvar os = require('os')\n\n// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'\nvar runtimeRequire = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require // eslint-disable-line\n\nvar vars = (process.config && process.config.variables) || {}\nvar prebuildsOnly = !!process.env.PREBUILDS_ONLY\nvar abi = process.versions.modules // TODO: support old node where this is undef\nvar runtime = isElectron() ? 'electron' : (isNwjs() ? 'node-webkit' : 'node')\n\nvar arch = process.env.npm_config_arch || os.arch()\nvar platform = process.env.npm_config_platform || os.platform()\nvar libc = process.env.LIBC || (isAlpine(platform) ? 'musl' : 'glibc')\nvar armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : vars.arm_version) || ''\nvar uv = (process.versions.uv || '').split('.')[0]\n\nmodule.exports = load\n\nfunction load (dir) {\n  return runtimeRequire(load.resolve(dir))\n}\n\nload.resolve = load.path = function (dir) {\n  dir = path.resolve(dir || '.')\n\n  try {\n    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_')\n    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD']\n  } catch (err) {}\n\n  if (!prebuildsOnly) {\n    var release = getFirst(path.join(dir, 'build/Release'), matchBuild)\n    if (release) return release\n\n    var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)\n    if (debug) return debug\n  }\n\n  var prebuild = resolve(dir)\n  if (prebuild) return prebuild\n\n  var nearby = resolve(path.dirname(process.execPath))\n  if (nearby) return nearby\n\n  var target = [\n    'platform=' + platform,\n    'arch=' + arch,\n    'runtime=' + runtime,\n    'abi=' + abi,\n    'uv=' + uv,\n    armv ? 'armv=' + armv : '',\n    'libc=' + libc,\n    'node=' + process.versions.node,\n    process.versions.electron ? 'electron=' + process.versions.electron : '',\n    typeof __webpack_require__ === 'function' ? 'webpack=true' : '' // eslint-disable-line\n  ].filter(Boolean).join(' ')\n\n  throw new Error('No native build was found for ' + target + '\\n    loaded from: ' + dir + '\\n')\n\n  function resolve (dir) {\n    // Find matching \"prebuilds/<platform>-<arch>\" directory\n    var tuples = readdirSync(path.join(dir, 'prebuilds')).map(parseTuple)\n    var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0]\n    if (!tuple) return\n\n    // Find most specific flavor first\n    var prebuilds = path.join(dir, 'prebuilds', tuple.name)\n    var parsed = readdirSync(prebuilds).map(parseTags)\n    var candidates = parsed.filter(matchTags(runtime, abi))\n    var winner = candidates.sort(compareTags(runtime))[0]\n    if (winner) return path.join(prebuilds, winner.file)\n  }\n}\n\nfunction readdirSync (dir) {\n  try {\n    return fs.readdirSync(dir)\n  } catch (err) {\n    return []\n  }\n}\n\nfunction getFirst (dir, filter) {\n  var files = readdirSync(dir).filter(filter)\n  return files[0] && path.join(dir, files[0])\n}\n\nfunction matchBuild (name) {\n  return /\\.node$/.test(name)\n}\n\nfunction parseTuple (name) {\n  // Example: darwin-x64+arm64\n  var arr = name.split('-')\n  if (arr.length !== 2) return\n\n  var platform = arr[0]\n  var architectures = arr[1].split('+')\n\n  if (!platform) return\n  if (!architectures.length) return\n  if (!architectures.every(Boolean)) return\n\n  return { name, platform, architectures }\n}\n\nfunction matchTuple (platform, arch) {\n  return function (tuple) {\n    if (tuple == null) return false\n    if (tuple.platform !== platform) return false\n    return tuple.architectures.includes(arch)\n  }\n}\n\nfunction compareTuples (a, b) {\n  // Prefer single-arch prebuilds over multi-arch\n  return a.architectures.length - b.architectures.length\n}\n\nfunction parseTags (file) {\n  var arr = file.split('.')\n  var extension = arr.pop()\n  var tags = { file: file, specificity: 0 }\n\n  if (extension !== 'node') return\n\n  for (var i = 0; i < arr.length; i++) {\n    var tag = arr[i]\n\n    if (tag === 'node' || tag === 'electron' || tag === 'node-webkit') {\n      tags.runtime = tag\n    } else if (tag === 'napi') {\n      tags.napi = true\n    } else if (tag.slice(0, 3) === 'abi') {\n      tags.abi = tag.slice(3)\n    } else if (tag.slice(0, 2) === 'uv') {\n      tags.uv = tag.slice(2)\n    } else if (tag.slice(0, 4) === 'armv') {\n      tags.armv = tag.slice(4)\n    } else if (tag === 'glibc' || tag === 'musl') {\n      tags.libc = tag\n    } else {\n      continue\n    }\n\n    tags.specificity++\n  }\n\n  return tags\n}\n\nfunction matchTags (runtime, abi) {\n  return function (tags) {\n    if (tags == null) return false\n    if (tags.runtime && tags.runtime !== runtime && !runtimeAgnostic(tags)) return false\n    if (tags.abi && tags.abi !== abi && !tags.napi) return false\n    if (tags.uv && tags.uv !== uv) return false\n    if (tags.armv && tags.armv !== armv) return false\n    if (tags.libc && tags.libc !== libc) return false\n\n    return true\n  }\n}\n\nfunction runtimeAgnostic (tags) {\n  return tags.runtime === 'node' && tags.napi\n}\n\nfunction compareTags (runtime) {\n  // Precedence: non-agnostic runtime, abi over napi, then by specificity.\n  return function (a, b) {\n    if (a.runtime !== b.runtime) {\n      return a.runtime === runtime ? -1 : 1\n    } else if (a.abi !== b.abi) {\n      return a.abi ? -1 : 1\n    } else if (a.specificity !== b.specificity) {\n      return a.specificity > b.specificity ? -1 : 1\n    } else {\n      return 0\n    }\n  }\n}\n\nfunction isNwjs () {\n  return !!(process.versions && process.versions.nw)\n}\n\nfunction isElectron () {\n  if (process.versions && process.versions.electron) return true\n  if (process.env.ELECTRON_RUN_AS_NODE) return true\n  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'\n}\n\nfunction isAlpine (platform) {\n  return platform === 'linux' && fs.existsSync('/etc/alpine-release')\n}\n\n// Exposed for unit tests\n// TODO: move to lib\nload.parseTags = parseTags\nload.matchTags = matchTags\nload.compareTags = compareTags\nload.parseTuple = parseTuple\nload.matchTuple = matchTuple\nload.compareTuples = compareTuples\n","const runtimeRequire = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require // eslint-disable-line\nif (typeof runtimeRequire.addon === 'function') { // if the platform supports native resolving prefer that\n  module.exports = runtimeRequire.addon.bind(runtimeRequire)\n} else { // else use the runtime version here\n  module.exports = require('./node-gyp-build.js')\n}\n","'use strict';\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nconst mask = (source, mask, output, offset, length) => {\n  for (var i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n};\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nconst unmask = (buffer, mask) => {\n  // Required until https://github.com/nodejs/node/issues/9006 is resolved.\n  const length = buffer.length;\n  for (var i = 0; i < length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n};\n\nmodule.exports = { mask, unmask };\n","'use strict';\n\ntry {\n  module.exports = require('node-gyp-build')(__dirname);\n} catch (e) {\n  module.exports = require('./fallback');\n}\n","'use strict';\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nfunction isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n\n  while (i < len) {\n    if ((buf[i] & 0x80) === 0x00) {  // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {  // 110xxxxx 10xxxxxx\n      if (\n        i + 1 === len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i] & 0xfe) === 0xc0  // overlong\n      ) {\n        return false;\n      }\n\n      i += 2;\n    } else if ((buf[i] & 0xf0) === 0xe0) {  // 1110xxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 2 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 ||  // overlong\n        buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0  // surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      }\n\n      i += 3;\n    } else if ((buf[i] & 0xf8) === 0xf0) {  // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 3 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i + 3] & 0xc0) !== 0x80 ||\n        buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 ||  // overlong\n        buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4  // > U+10FFFF\n      ) {\n        return false;\n      }\n\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = isValidUTF8;\n","'use strict';\n\ntry {\n  module.exports = require('node-gyp-build')(__dirname);\n} catch (e) {\n  module.exports = require('./fallback');\n}\n","function promisifyRequest(request) {\n    return new Promise((resolve, reject) => {\n        // @ts-ignore - file size hacks\n        request.oncomplete = request.onsuccess = () => resolve(request.result);\n        // @ts-ignore - file size hacks\n        request.onabort = request.onerror = () => reject(request.error);\n    });\n}\nfunction createStore(dbName, storeName) {\n    const request = indexedDB.open(dbName);\n    request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n    const dbp = promisifyRequest(request);\n    return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));\n}\nlet defaultGetStoreFunc;\nfunction defaultGetStore() {\n    if (!defaultGetStoreFunc) {\n        defaultGetStoreFunc = createStore('keyval-store', 'keyval');\n    }\n    return defaultGetStoreFunc;\n}\n/**\n * Get a value by its key.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction get(key, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => promisifyRequest(store.get(key)));\n}\n/**\n * Set a value with a key.\n *\n * @param key\n * @param value\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction set(key, value, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.put(value, key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Set multiple values at once. This is faster than calling set() multiple times.\n * It's also atomic â€“ if one of the pairs can't be added, none will be added.\n *\n * @param entries Array of entries, where each entry is an array of `[key, value]`.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction setMany(entries, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        entries.forEach((entry) => store.put(entry[1], entry[0]));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Get multiple values by their keys\n *\n * @param keys\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction getMany(keys, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => Promise.all(keys.map((key) => promisifyRequest(store.get(key)))));\n}\n/**\n * Update a value. This lets you see the old value and update it as an atomic operation.\n *\n * @param key\n * @param updater A callback that takes the old value and returns a new value.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction update(key, updater, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => \n    // Need to create the promise manually.\n    // If I try to chain promises, the transaction closes in browsers\n    // that use a promise polyfill (IE10/11).\n    new Promise((resolve, reject) => {\n        store.get(key).onsuccess = function () {\n            try {\n                store.put(updater(this.result), key);\n                resolve(promisifyRequest(store.transaction));\n            }\n            catch (err) {\n                reject(err);\n            }\n        };\n    }));\n}\n/**\n * Delete a particular key from the store.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction del(key, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.delete(key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Delete multiple keys at once.\n *\n * @param keys List of keys to delete.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction delMany(keys, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        keys.forEach((key) => store.delete(key));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Clear all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction clear(customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.clear();\n        return promisifyRequest(store.transaction);\n    });\n}\nfunction eachCursor(store, callback) {\n    store.openCursor().onsuccess = function () {\n        if (!this.result)\n            return;\n        callback(this.result);\n        this.result.continue();\n    };\n    return promisifyRequest(store.transaction);\n}\n/**\n * Get all keys in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction keys(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAllKeys) {\n            return promisifyRequest(store.getAllKeys());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);\n    });\n}\n/**\n * Get all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction values(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAll) {\n            return promisifyRequest(store.getAll());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.value)).then(() => items);\n    });\n}\n/**\n * Get all entries in the store. Each entry is an array of `[key, value]`.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction entries(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        // (although, hopefully we'll get a simpler path some day)\n        if (store.getAll && store.getAllKeys) {\n            return Promise.all([\n                promisifyRequest(store.getAllKeys()),\n                promisifyRequest(store.getAll()),\n            ]).then(([keys, values]) => keys.map((key, i) => [key, values[i]]));\n        }\n        const items = [];\n        return customStore('readonly', (store) => eachCursor(store, (cursor) => items.push([cursor.key, cursor.value])).then(() => items));\n    });\n}\n\nexport { clear, createStore, del, delMany, entries, get, getMany, keys, promisifyRequest, set, setMany, update, values };\n","export const PROTOCOL = \"wc\";\nexport const WC_VERSION = 2;\nexport const CONTEXT = \"ethereum_provider\";\nexport const STORAGE_KEY = `${PROTOCOL}@${WC_VERSION}:${CONTEXT}:`;\nexport const RPC_URL = \"https://rpc.walletconnect.org/v1/\";\n","export const REQUIRED_METHODS = [\"eth_sendTransaction\", \"personal_sign\"];\nexport const OPTIONAL_METHODS = [\n  \"eth_accounts\",\n  \"eth_requestAccounts\",\n  \"eth_sendRawTransaction\",\n  \"eth_sign\",\n  \"eth_signTransaction\",\n  \"eth_signTypedData\",\n  \"eth_signTypedData_v3\",\n  \"eth_signTypedData_v4\",\n  \"eth_sendTransaction\",\n  \"personal_sign\",\n  \"wallet_switchEthereumChain\",\n  \"wallet_addEthereumChain\",\n  \"wallet_getPermissions\",\n  \"wallet_requestPermissions\",\n  \"wallet_registerOnboarding\",\n  \"wallet_watchAsset\",\n  \"wallet_scanQRCode\",\n  \"wallet_sendCalls\",\n  \"wallet_getCapabilities\",\n  \"wallet_getCallsStatus\",\n  \"wallet_showCallsStatus\",\n];\nexport const REQUIRED_EVENTS = [\"chainChanged\", \"accountsChanged\"];\nexport const OPTIONAL_EVENTS = [\n  \"chainChanged\",\n  \"accountsChanged\",\n  \"message\",\n  \"disconnect\",\n  \"connect\",\n];\n","export const getAppkit = async () => {\n  const { createAppKit } = await import(\"@reown/appkit/core\");\n  return createAppKit;\n};\n","import { EventEmitter } from \"events\";\nimport { getAccountsFromNamespaces, getSdkError, isValidArray } from \"@walletconnect/utils\";\nimport { KeyValueStorageOptions } from \"@walletconnect/keyvaluestorage\";\nimport {\n  IEthereumProvider as IProvider,\n  IEthereumProviderEvents,\n  ProviderAccounts,\n  RequestArguments,\n  QrModalOptions,\n} from \"./types.js\";\nimport {\n  Metadata,\n  Namespace,\n  UniversalProvider,\n  UniversalProviderOpts,\n} from \"@walletconnect/universal-provider\";\nimport { AuthTypes, SessionTypes, SignClientTypes } from \"@walletconnect/types\";\nimport { JsonRpcResult } from \"@walletconnect/jsonrpc-types\";\nimport {\n  STORAGE_KEY,\n  REQUIRED_METHODS,\n  REQUIRED_EVENTS,\n  RPC_URL,\n  OPTIONAL_METHODS,\n  OPTIONAL_EVENTS,\n} from \"./constants/index.js\";\nimport { getAppkit } from \"./utils/appkit.js\";\n\nexport type RpcMethod =\n  | \"personal_sign\"\n  | \"eth_sendTransaction\"\n  | \"eth_accounts\"\n  | \"eth_requestAccounts\"\n  | \"eth_call\"\n  | \"eth_getBalance\"\n  | \"eth_sendRawTransaction\"\n  | \"eth_sign\"\n  | \"eth_signTransaction\"\n  | \"eth_signTypedData\"\n  | \"eth_signTypedData_v3\"\n  | \"eth_signTypedData_v4\"\n  | \"wallet_switchEthereumChain\"\n  | \"wallet_addEthereumChain\"\n  | \"wallet_getPermissions\"\n  | \"wallet_requestPermissions\"\n  | \"wallet_registerOnboarding\"\n  | \"wallet_watchAsset\"\n  | \"wallet_scanQRCode\"\n  | \"wallet_sendCalls\"\n  | \"wallet_getCapabilities\"\n  | \"wallet_getCallsStatus\"\n  | \"wallet_showCallsStatus\";\n\nexport type RpcEvent = \"accountsChanged\" | \"chainChanged\" | \"message\" | \"disconnect\" | \"connect\";\n\nexport interface EthereumRpcMap {\n  [chainId: string]: string;\n}\n\nexport interface SessionEvent {\n  event: { name: string; data: any };\n  chainId: string;\n}\n\nexport interface EthereumRpcConfig {\n  chains: string[];\n  optionalChains: string[];\n  methods: string[];\n  optionalMethods?: string[];\n  /**\n   * @description Events that the wallet MUST support or the connection will be rejected\n   */\n  events: string[];\n  optionalEvents?: string[];\n  rpcMap: EthereumRpcMap;\n  projectId: string;\n  metadata?: Metadata;\n  showQrModal: boolean;\n  qrModalOptions?: QrModalOptions;\n}\nexport interface ConnectOps {\n  chains?: number[];\n  optionalChains?: number[];\n  rpcMap?: EthereumRpcMap;\n  pairingTopic?: string;\n  scopedProperties?: unknown;\n}\n\nexport type AuthenticateParams = {\n  chains?: number[];\n} & Omit<AuthTypes.SessionAuthenticateParams, \"chains\">;\n\nexport interface IEthereumProvider extends IProvider {\n  connect(opts?: ConnectOps | undefined): Promise<void>;\n}\n\nexport function getRpcUrl(chainId: string, rpc: EthereumRpcConfig): string | undefined {\n  let rpcUrl: string | undefined;\n  if (rpc.rpcMap) {\n    rpcUrl = rpc.rpcMap[getEthereumChainId([chainId])];\n  }\n  return rpcUrl;\n}\n\nexport function getEthereumChainId(chains: string[]): number {\n  return Number(chains[0].split(\":\")[1]);\n}\n\nexport function toHexChainId(chainId: number): string {\n  return `0x${chainId.toString(16)}`;\n}\n\nexport type NamespacesParams = {\n  chains: EthereumRpcConfig[\"chains\"];\n  optionalChains: EthereumRpcConfig[\"optionalChains\"];\n  methods?: EthereumRpcConfig[\"methods\"];\n  optionalMethods?: EthereumRpcConfig[\"methods\"];\n  events?: EthereumRpcConfig[\"events\"];\n  rpcMap: EthereumRpcConfig[\"rpcMap\"];\n  optionalEvents?: EthereumRpcConfig[\"events\"];\n};\n\nexport function buildNamespaces(params: NamespacesParams): {\n  required?: Namespace;\n  optional?: Namespace;\n} {\n  const { chains, optionalChains, methods, optionalMethods, events, optionalEvents, rpcMap } =\n    params;\n  if (!isValidArray(chains)) {\n    throw new Error(\"Invalid chains\");\n  }\n\n  const required: Namespace = {\n    chains,\n    methods: methods || REQUIRED_METHODS,\n    events: events || REQUIRED_EVENTS,\n    rpcMap: {\n      ...(chains.length\n        ? { [getEthereumChainId(chains)]: rpcMap[getEthereumChainId(chains)] }\n        : {}),\n    },\n  };\n\n  // make a list of events and methods that require additional permissions\n  // so we know if we should to include the required chains in the optional namespace\n  const eventsRequiringPermissions = events?.filter((event) => !REQUIRED_EVENTS.includes(event));\n  const methodsRequiringPermissions = methods?.filter((event) => !REQUIRED_METHODS.includes(event));\n\n  if (\n    !optionalChains &&\n    !optionalEvents &&\n    !optionalMethods &&\n    !eventsRequiringPermissions?.length &&\n    !methodsRequiringPermissions?.length\n  ) {\n    return { required: chains.length ? required : undefined };\n  }\n\n  /*\n   * decides whether or not to include the required chains in the optional namespace\n   * use case: if there is a single chain as required but additional methods/events as optional\n   */\n  const shouldIncludeRequiredChains =\n    (eventsRequiringPermissions?.length && methodsRequiringPermissions?.length) || !optionalChains;\n\n  const optional: Namespace = {\n    chains: [\n      ...new Set(\n        shouldIncludeRequiredChains ? required.chains.concat(optionalChains || []) : optionalChains,\n      ),\n    ],\n    methods: [\n      ...new Set(\n        required.methods.concat(optionalMethods?.length ? optionalMethods : OPTIONAL_METHODS),\n      ),\n    ],\n    events: [\n      ...new Set(required.events.concat(optionalEvents?.length ? optionalEvents : OPTIONAL_EVENTS)),\n    ],\n    rpcMap,\n  };\n\n  return {\n    required: chains.length ? required : undefined,\n    optional: optionalChains.length ? optional : undefined,\n  };\n}\n\n// helper type to force setting at least one value in an array\ntype ArrayOneOrMore<T> = {\n  0: T;\n} & Array<T>;\n\n/**\n * @param {number[]} chains - The Chains your app intents to use and the peer MUST support. If the peer does not support these chains, the connection will be rejected.\n * @param {number[]} optionalChains - The Chains your app MAY attempt to use and the peer MAY support. If the peer does not support these chains, the connection will still be established.\n * @description either chains or optionalChains must be provided\n */\nexport type ChainsProps =\n  | {\n      chains: ArrayOneOrMore<number>;\n      optionalChains?: number[];\n    }\n  | {\n      chains?: number[];\n      optionalChains: ArrayOneOrMore<number>;\n    };\n\nexport type EthereumProviderOptions = {\n  projectId: string;\n  /**\n   * @note Methods that your app intents to use and the peer MUST support. If the peer does not support these methods, the connection will be rejected.\n   * @default [\"eth_sendTransaction\", \"personal_sign\"]\n   */\n  methods?: string[];\n  /**\n   * @note Methods that your app MAY attempt to use and the peer MAY support. If the peer does not support these methods, the connection will still be established.\n   */\n  optionalMethods?: string[];\n  events?: string[];\n  optionalEvents?: string[];\n  rpcMap?: EthereumRpcMap;\n  metadata?: Metadata;\n  showQrModal: boolean;\n  qrModalOptions?: QrModalOptions;\n  disableProviderPing?: boolean;\n  relayUrl?: string;\n  storageOptions?: KeyValueStorageOptions;\n} & ChainsProps &\n  UniversalProviderOpts;\n\nexport class EthereumProvider implements IEthereumProvider {\n  public events = new EventEmitter();\n  public namespace = \"eip155\";\n  public accounts: string[] = [];\n  public signer: InstanceType<typeof UniversalProvider>;\n  public chainId = 1;\n  public modal?: any;\n\n  protected rpc: EthereumRpcConfig;\n  protected readonly STORAGE_KEY = STORAGE_KEY;\n\n  constructor() {\n    // assigned during initialize\n    this.signer = {} as InstanceType<typeof UniversalProvider>;\n    this.rpc = {} as EthereumRpcConfig;\n  }\n\n  static async init(opts: EthereumProviderOptions): Promise<EthereumProvider> {\n    const provider = new EthereumProvider();\n    await provider.initialize(opts);\n    return provider;\n  }\n\n  public async request<T = unknown>(args: RequestArguments, expiry?: number): Promise<T> {\n    return await this.signer.request(args, this.formatChainId(this.chainId), expiry);\n  }\n\n  public sendAsync(\n    args: RequestArguments,\n    callback: (error: Error | null, response: JsonRpcResult) => void,\n    expiry?: number,\n  ): void {\n    this.signer.sendAsync(args, callback, this.formatChainId(this.chainId), expiry);\n  }\n\n  get connected(): boolean {\n    if (!this.signer.client) return false;\n    return this.signer.client.core.relayer.connected;\n  }\n\n  get connecting(): boolean {\n    if (!this.signer.client) return false;\n    return this.signer.client.core.relayer.connecting;\n  }\n\n  public async enable(): Promise<ProviderAccounts> {\n    if (!this.session) await this.connect();\n    const accounts = await this.request({ method: \"eth_requestAccounts\" });\n    return accounts as ProviderAccounts;\n  }\n\n  public async connect(opts?: ConnectOps): Promise<void> {\n    if (!this.signer.client) {\n      throw new Error(\"Provider not initialized. Call init() first\");\n    }\n\n    this.loadConnectOpts(opts);\n    const { required, optional } = buildNamespaces(this.rpc);\n    try {\n      const session = await new Promise<SessionTypes.Struct | undefined>(\n        async (resolve, reject) => {\n          if (this.rpc.showQrModal) {\n            this.modal?.open();\n\n            this.modal?.subscribeState((state: { open: boolean }) => {\n              // the modal was closed so reject the promise\n              if (!state.open && !this.signer.session) {\n                this.signer.abortPairingAttempt();\n                reject(new Error(\"Connection request reset. Please try again.\"));\n              }\n            });\n          }\n          const scopedProperties = opts?.scopedProperties\n            ? { [this.namespace]: opts.scopedProperties }\n            : undefined;\n\n          await this.signer\n            .connect({\n              namespaces: {\n                ...(required && {\n                  [this.namespace]: required,\n                }),\n              },\n              ...(optional && {\n                optionalNamespaces: {\n                  [this.namespace]: optional,\n                },\n              }),\n              pairingTopic: opts?.pairingTopic,\n              scopedProperties,\n            })\n            .then((session?: SessionTypes.Struct) => {\n              resolve(session);\n            })\n            .catch((error: Error) => {\n              this.modal?.showErrorMessage(\"Unable to connect\");\n              reject(new Error(error.message));\n            });\n        },\n      );\n\n      if (!session) return;\n\n      const accounts = getAccountsFromNamespaces(session.namespaces, [this.namespace]);\n      // if no required chains are set, use the approved accounts to fetch chainIds\n      this.setChainIds(this.rpc.chains.length ? this.rpc.chains : accounts);\n      this.setAccounts(accounts);\n      this.events.emit(\"connect\", { chainId: toHexChainId(this.chainId) });\n    } catch (error) {\n      this.signer.logger.error(error);\n      throw error;\n    } finally {\n      this.modal?.close();\n    }\n  }\n\n  public async authenticate(\n    params: AuthenticateParams,\n    walletUniversalLink?: string,\n  ): Promise<AuthTypes.AuthenticateResponseResult | undefined> {\n    if (!this.signer.client) {\n      throw new Error(\"Provider not initialized. Call init() first\");\n    }\n\n    this.loadConnectOpts({\n      chains: params?.chains,\n    });\n\n    try {\n      const result = await new Promise<AuthTypes.AuthenticateResponseResult>(\n        async (resolve, reject) => {\n          if (this.rpc.showQrModal) {\n            this.modal?.open();\n            this.modal?.subscribeState((state: { open: boolean }) => {\n              // the modal was closed so reject the promise\n              if (!state.open && !this.signer.session) {\n                this.signer.abortPairingAttempt();\n                reject(new Error(\"Connection request reset. Please try again.\"));\n              }\n            });\n          }\n          await this.signer\n            .authenticate(\n              {\n                ...params,\n                chains: this.rpc.chains,\n              },\n              walletUniversalLink,\n            )\n            .then((result: AuthTypes.AuthenticateResponseResult) => {\n              resolve(result);\n            })\n            .catch((error: Error) => {\n              this.modal?.showErrorMessage(\"Unable to connect\");\n              reject(new Error(error.message));\n            });\n        },\n      );\n\n      const session = result.session;\n      if (session) {\n        const accounts = getAccountsFromNamespaces(session.namespaces, [this.namespace]);\n        // if no required chains are set, use the approved accounts to fetch chainIds as both contain <namespace>:<chainId>\n        this.setChainIds(this.rpc.chains.length ? this.rpc.chains : accounts);\n        this.setAccounts(accounts);\n\n        this.events.emit(\"connect\", { chainId: toHexChainId(this.chainId) });\n      }\n\n      return result;\n    } catch (error) {\n      this.signer.logger.error(error);\n      throw error;\n    } finally {\n      this.modal?.close();\n    }\n  }\n\n  public async disconnect(): Promise<void> {\n    if (this.session) {\n      await this.signer.disconnect();\n    }\n    this.reset();\n  }\n\n  public on: IEthereumProviderEvents[\"on\"] = (event, listener) => {\n    this.events.on(event, listener);\n    return this;\n  };\n\n  public once: IEthereumProviderEvents[\"once\"] = (event, listener) => {\n    this.events.once(event, listener);\n    return this;\n  };\n\n  public removeListener: IEthereumProviderEvents[\"removeListener\"] = (event, listener) => {\n    this.events.removeListener(event, listener);\n    return this;\n  };\n\n  public off: IEthereumProviderEvents[\"off\"] = (event, listener) => {\n    this.events.off(event, listener);\n    return this;\n  };\n\n  get isWalletConnect() {\n    return true;\n  }\n\n  get session() {\n    return this.signer.session;\n  }\n\n  // ---------- Protected --------------------------------------------- //\n\n  protected registerEventListeners() {\n    this.signer.on(\"session_event\", (payload: SignClientTypes.EventArguments[\"session_event\"]) => {\n      const { params } = payload;\n      const { event } = params;\n      if (event.name === \"accountsChanged\") {\n        this.accounts = this.parseAccounts(event.data);\n        this.events.emit(\"accountsChanged\", this.accounts);\n      } else if (event.name === \"chainChanged\") {\n        this.setChainId(this.formatChainId(event.data));\n      } else {\n        this.events.emit(event.name as any, event.data);\n      }\n      this.events.emit(\"session_event\", payload);\n    });\n\n    this.signer.on(\"accountsChanged\", (accounts: string[]) => {\n      this.accounts = this.parseAccounts(accounts);\n      this.events.emit(\"accountsChanged\", this.accounts);\n    });\n\n    this.signer.on(\"chainChanged\", (chainId: string) => {\n      const chain = parseInt(chainId);\n      this.chainId = chain;\n      this.events.emit(\"chainChanged\", toHexChainId(this.chainId));\n      this.persist();\n    });\n\n    this.signer.on(\n      \"session_update\",\n      (payload: SignClientTypes.EventArguments[\"session_update\"]) => {\n        this.events.emit(\"session_update\", payload);\n      },\n    );\n\n    this.signer.on(\n      \"session_delete\",\n      (payload: SignClientTypes.EventArguments[\"session_delete\"]) => {\n        this.reset();\n        this.events.emit(\"session_delete\", payload);\n        this.events.emit(\"disconnect\", {\n          ...getSdkError(\"USER_DISCONNECTED\"),\n          data: payload.topic,\n          name: \"USER_DISCONNECTED\",\n        });\n      },\n    );\n\n    this.signer.on(\"display_uri\", (uri: string) => {\n      this.events.emit(\"display_uri\", uri);\n    });\n  }\n\n  protected switchEthereumChain(chainId: number): void {\n    this.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{ chainId: chainId.toString(16) }],\n    });\n  }\n\n  protected isCompatibleChainId(chainId: string): boolean {\n    return typeof chainId === \"string\" ? chainId.startsWith(`${this.namespace}:`) : false;\n  }\n\n  protected formatChainId(chainId: number): string {\n    return `${this.namespace}:${chainId}`;\n  }\n\n  protected parseChainId(chainId: string): number {\n    return Number(chainId.split(\":\")[1]);\n  }\n\n  protected setChainIds(chains: string[]) {\n    const compatible = chains.filter((x) => this.isCompatibleChainId(x));\n    const chainIds = compatible.map((c) => this.parseChainId(c));\n    if (chainIds.length) {\n      this.chainId = chainIds[0];\n      this.events.emit(\"chainChanged\", toHexChainId(this.chainId));\n      this.persist();\n    }\n  }\n\n  protected setChainId(chain: string) {\n    if (this.isCompatibleChainId(chain)) {\n      const chainId = this.parseChainId(chain);\n      this.chainId = chainId;\n      this.switchEthereumChain(chainId);\n    }\n  }\n\n  protected parseAccountId(account: string): { chainId: string; address: string } {\n    const [namespace, reference, address] = account.split(\":\");\n    const chainId = `${namespace}:${reference}`;\n    return { chainId, address };\n  }\n\n  protected setAccounts(accounts: string[]) {\n    this.accounts = accounts\n      .filter((x) => this.parseChainId(this.parseAccountId(x).chainId) === this.chainId)\n      .map((x) => this.parseAccountId(x).address);\n    this.events.emit(\"accountsChanged\", this.accounts);\n  }\n\n  protected getRpcConfig(opts: EthereumProviderOptions): EthereumRpcConfig {\n    const requiredChains = opts?.chains ?? [];\n    const optionalChains = opts?.optionalChains ?? [];\n    const allChains = requiredChains.concat(optionalChains);\n    if (!allChains.length)\n      throw new Error(\"No chains specified in either `chains` or `optionalChains`\");\n    const requiredMethods = requiredChains.length ? opts?.methods || REQUIRED_METHODS : [];\n    const requiredEvents = requiredChains.length ? opts?.events || REQUIRED_EVENTS : [];\n    const optionalMethods = opts?.optionalMethods || [];\n    const optionalEvents = opts?.optionalEvents || [];\n    const rpcMap = opts?.rpcMap || this.buildRpcMap(allChains, opts.projectId);\n    const qrModalOptions = opts?.qrModalOptions || undefined;\n    return {\n      chains: requiredChains?.map((chain: number) => this.formatChainId(chain)),\n      optionalChains: optionalChains.map((chain: number) => this.formatChainId(chain)),\n      methods: requiredMethods,\n      events: requiredEvents,\n      optionalMethods,\n      optionalEvents,\n      rpcMap,\n      showQrModal: Boolean(opts?.showQrModal),\n      qrModalOptions,\n      projectId: opts.projectId,\n      metadata: opts.metadata,\n    };\n  }\n\n  protected buildRpcMap(chains: number[], projectId: string): EthereumRpcMap {\n    const map: EthereumRpcMap = {};\n    chains.forEach((chain) => {\n      map[chain] = this.getRpcUrl(chain, projectId);\n    });\n    return map;\n  }\n\n  protected async initialize(opts: EthereumProviderOptions) {\n    this.rpc = this.getRpcConfig(opts);\n\n    this.chainId = this.rpc.chains.length\n      ? getEthereumChainId(this.rpc.chains)\n      : getEthereumChainId(this.rpc.optionalChains);\n    this.signer = await UniversalProvider.init({\n      projectId: this.rpc.projectId,\n      metadata: this.rpc.metadata,\n      disableProviderPing: opts.disableProviderPing,\n      relayUrl: opts.relayUrl,\n      storage: opts.storage,\n      storageOptions: opts.storageOptions,\n      customStoragePrefix: opts.customStoragePrefix,\n      telemetryEnabled: opts.telemetryEnabled,\n      logger: opts.logger,\n    });\n    this.registerEventListeners();\n    await this.loadPersistedSession();\n    if (this.rpc.showQrModal) {\n      let appKit;\n      try {\n        const createAppKit = await getAppkit();\n        const { convertWCMToAppKitOptions } = await import(\"./wcmToAppKit.js\");\n        const options = convertWCMToAppKitOptions({\n          ...this.rpc.qrModalOptions,\n          chains: [...new Set([...this.rpc.chains, ...this.rpc.optionalChains])],\n          metadata: this.rpc.metadata,\n          projectId: this.rpc.projectId,\n        });\n\n        if (!options.networks.length) {\n          throw new Error(\"No networks found for WalletConnect\");\n        }\n\n        appKit = createAppKit({\n          ...options,\n          universalProvider: this.signer as any,\n          manualWCControl: true,\n          enableMobileFullScreen: this.rpc.qrModalOptions?.enableMobileFullScreen === true,\n        });\n      } catch (e) {\n        console.warn(e);\n        throw new Error(\"To use QR modal, please install @reown/appkit package\");\n      }\n      if (appKit) {\n        try {\n          this.modal = appKit;\n        } catch (e) {\n          this.signer.logger.error(e);\n          throw new Error(\"Could not generate WalletConnectModal Instance\");\n        }\n      }\n    }\n  }\n\n  protected loadConnectOpts(opts?: ConnectOps) {\n    if (!opts) return;\n    const { chains, optionalChains, rpcMap } = opts;\n    if (chains && isValidArray(chains)) {\n      this.rpc.chains = chains.map((chain) => this.formatChainId(chain));\n      chains.forEach((chain) => {\n        this.rpc.rpcMap[chain] = rpcMap?.[chain] || this.getRpcUrl(chain);\n      });\n    }\n    if (optionalChains && isValidArray(optionalChains)) {\n      this.rpc.optionalChains = [];\n      this.rpc.optionalChains = optionalChains?.map((chain) => this.formatChainId(chain));\n      optionalChains.forEach((chain) => {\n        this.rpc.rpcMap[chain] = rpcMap?.[chain] || this.getRpcUrl(chain);\n      });\n    }\n  }\n\n  protected getRpcUrl(chainId: number, projectId?: string): string {\n    const providedRpc = this.rpc.rpcMap?.[chainId];\n    return (\n      providedRpc ||\n      `${RPC_URL}?chainId=eip155:${chainId}&projectId=${projectId || this.rpc.projectId}`\n    );\n  }\n\n  protected async loadPersistedSession() {\n    if (!this.session) return;\n    try {\n      const chainId = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`);\n\n      // cater to both inline & nested namespace formats\n      const namespace = this.session.namespaces[`${this.namespace}:${chainId}`]\n        ? this.session.namespaces[`${this.namespace}:${chainId}`]\n        : this.session.namespaces[this.namespace];\n\n      this.setChainIds(chainId ? [this.formatChainId(chainId)] : namespace?.accounts);\n      this.setAccounts(namespace?.accounts);\n    } catch (error) {\n      this.signer.logger.error(\"Failed to load persisted session, clearing state...\");\n      this.signer.logger.error(error);\n      await this.disconnect().catch((error) => this.signer.logger.warn(error));\n    }\n  }\n\n  protected reset() {\n    this.chainId = 1;\n    this.accounts = [];\n  }\n\n  protected persist() {\n    if (!this.session) return;\n    this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);\n  }\n\n  protected parseAccounts(payload: string | string[]): string[] {\n    if (typeof payload === \"string\" || payload instanceof String) {\n      return [this.parseAccount(payload)];\n    }\n    return payload.map((account: string) => this.parseAccount(account));\n  }\n\n  protected parseAccount = (payload: any): string => {\n    return this.isCompatibleChainId(payload) ? this.parseAccountId(payload).address : payload;\n  };\n}\n\nexport default EthereumProvider;\n","import { EthereumProvider as Provider } from \"./EthereumProvider.js\";\nexport const EthereumProvider = Provider;\nexport type { EthereumProviderOptions, RpcEvent, RpcMethod } from \"./EthereumProvider\";\nexport * from \"./constants/rpc.js\";\nexport default Provider;\n","import type { AppKitOptions, CaipNetwork, CaipNetworkId } from \"@reown/appkit\";\nimport type { WalletConnectModalConfig, Assign, ChainFormatters, Prettify } from \"./types.js\";\nimport type { AppKitNetwork } from \"@reown/appkit/networks\";\nimport type { EthereumProviderOptions } from \"./EthereumProvider.js\";\n\nfunction convertThemeVariables(\n  wcmTheme?: WalletConnectModalConfig[\"themeVariables\"],\n): AppKitOptions[\"themeVariables\"] | undefined {\n  if (!wcmTheme) return undefined;\n\n  return {\n    \"--w3m-font-family\": wcmTheme[\"--wcm-font-family\"],\n    \"--w3m-accent\": wcmTheme[\"--wcm-accent-color\"],\n    \"--w3m-color-mix\": wcmTheme[\"--wcm-background-color\"],\n    \"--w3m-z-index\": wcmTheme[\"--wcm-z-index\"] ? Number(wcmTheme[\"--wcm-z-index\"]) : undefined,\n\n    \"--w3m-qr-color\": wcmTheme[\"--wcm-accent-color\"],\n\n    \"--w3m-font-size-master\": wcmTheme[\"--wcm-text-medium-regular-size\"],\n    \"--w3m-border-radius-master\": wcmTheme[\"--wcm-container-border-radius\"],\n    \"--w3m-color-mix-strength\": 0,\n  };\n}\n\nconst mapCaipIdToAppKitCaipNetwork = (caipId: CaipNetworkId): CaipNetwork => {\n  const [namespace, chainId] = caipId.split(\":\");\n  const chain = defineChain({\n    id: chainId,\n    caipNetworkId: caipId,\n    chainNamespace: namespace as CaipNetwork[\"chainNamespace\"],\n    name: \"\",\n    nativeCurrency: {\n      name: \"\",\n      symbol: \"\",\n      decimals: 8,\n    },\n    rpcUrls: {\n      default: { http: [\"https://rpc.walletconnect.org/v1\"] },\n    },\n  });\n\n  return chain as CaipNetwork;\n};\n\nexport function convertWCMToAppKitOptions(\n  wcmConfig: WalletConnectModalConfig & { metadata?: EthereumProviderOptions[\"metadata\"] },\n): AppKitOptions {\n  // Convert chains toCaipNetwork format\n  const networks: CaipNetwork[] = (wcmConfig.chains as CaipNetworkId[])\n    ?.map(mapCaipIdToAppKitCaipNetwork)\n    .filter(Boolean);\n\n  // Ensure at least one network is present\n  if (networks.length === 0) {\n    throw new Error(\"At least one chain must be specified\");\n  }\n\n  const defaultNetwork = networks.find((network) => network.id === wcmConfig.defaultChain?.id);\n  const appKitOptions: AppKitOptions = {\n    projectId: wcmConfig.projectId,\n    networks: networks as [AppKitNetwork, ...AppKitNetwork[]],\n    themeMode: wcmConfig.themeMode,\n    themeVariables: convertThemeVariables(wcmConfig.themeVariables),\n    chainImages: wcmConfig.chainImages,\n    connectorImages: wcmConfig.walletImages,\n    defaultNetwork,\n    metadata: {\n      ...wcmConfig.metadata,\n      name: wcmConfig.metadata?.name || \"WalletConnect\",\n      description: wcmConfig.metadata?.description || \"Connect to WalletConnect-compatible wallets\",\n      url: wcmConfig.metadata?.url || \"https://walletconnect.org\",\n      icons: wcmConfig.metadata?.icons || [\"https://walletconnect.org/walletconnect-logo.png\"],\n    },\n    showWallets: true,\n    // Explorer options mapping\n    featuredWalletIds:\n      wcmConfig.explorerRecommendedWalletIds === \"NONE\"\n        ? []\n        : Array.isArray(wcmConfig.explorerRecommendedWalletIds)\n          ? wcmConfig.explorerRecommendedWalletIds\n          : [],\n\n    excludeWalletIds:\n      wcmConfig.explorerExcludedWalletIds === \"ALL\"\n        ? []\n        : Array.isArray(wcmConfig.explorerExcludedWalletIds)\n          ? wcmConfig.explorerExcludedWalletIds\n          : [],\n\n    // Additional AppKit-specific options that don't have direct WCM equivalents\n    enableEIP6963: false, // Disable 6963 by default\n    enableInjected: false, // Disable injected by default\n    enableCoinbase: true, // Default to true\n    enableWalletConnect: true, // Default to true,\n    features: {\n      email: false,\n      socials: false,\n    },\n  };\n\n  // Add mobile and desktop wallets as custom wallets if provided\n  if (wcmConfig.mobileWallets?.length || wcmConfig.desktopWallets?.length) {\n    const customWallets = [\n      ...(wcmConfig.mobileWallets || []).map((wallet) => ({\n        id: wallet.id,\n        name: wallet.name,\n        links: wallet.links,\n      })),\n      ...(wcmConfig.desktopWallets || []).map((wallet) => ({\n        id: wallet.id,\n        name: wallet.name,\n        links: {\n          native: wallet.links.native,\n          universal: wallet.links.universal,\n        },\n      })),\n    ];\n\n    const allWallets = [\n      ...(appKitOptions.featuredWalletIds || []),\n      ...(appKitOptions.excludeWalletIds || []),\n    ];\n\n    // Only add a custom wallet if it's not on the other lists\n    const uniqueCustomWallets = customWallets.filter((wallet) => !allWallets.includes(wallet.id));\n\n    if (uniqueCustomWallets.length) {\n      appKitOptions.customWallets = uniqueCustomWallets;\n    }\n  }\n\n  return appKitOptions;\n}\n\nexport function defineChain<\n  formatters extends ChainFormatters,\n  const chain extends CaipNetwork<formatters>,\n>(chain: chain): Prettify<Assign<CaipNetwork<undefined>, chain>> {\n  return {\n    formatters: undefined,\n    fees: undefined,\n    serializers: undefined,\n    ...chain,\n  } as Assign<CaipNetwork<undefined>, chain>;\n}\n"],"names":["createAppKit","chains","chainId","params","optionalChains","methods","optionalMethods","events","optionalEvents","rpcMap","isValidArray","required","REQUIRED_METHODS","REQUIRED_EVENTS","__spreadValues","eventsRequiringPermissions","event","methodsRequiringPermissions","shouldIncludeRequiredChains","optional","OPTIONAL_METHODS","OPTIONAL_EVENTS","EthereumProvider","__publicField","EventEmitter","STORAGE_KEY","listener","payload","opts","provider","args","expiry","callback","_a","session","resolve","reject","_b","state","scopedProperties","__spreadProps","error","accounts","getAccountsFromNamespaces","walletUniversalLink","result","chain","getSdkError","uri","chainIds","x","c","account","namespace","reference","address","requiredChains","allChains","requiredMethods","requiredEvents","qrModalOptions","projectId","map","UniversalProvider","appKit","getAppkit","convertWCMToAppKitOptions","options","e","RPC_URL","Provider","convertThemeVariables","wcmTheme","mapCaipIdToAppKitCaipNetwork","caipId","wcmConfig","_c","_d","_e","_f","_g","networks","defaultNetwork","network","appKitOptions","customWallets","wallet","allWallets","uniqueCustomWallets"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6]}