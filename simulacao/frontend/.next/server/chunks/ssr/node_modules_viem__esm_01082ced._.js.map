{"version":3,"sources":["turbopack:///[project]/node_modules/viem/utils/chain/assertCurrentChain.ts","turbopack:///[project]/node_modules/viem/utils/errors/getTransactionError.ts","turbopack:///[project]/node_modules/viem/actions/wallet/sendTransaction.ts","turbopack:///[project]/node_modules/viem/actions/wallet/writeContract.ts"],"sourcesContent":["import {\n  ChainMismatchError,\n  type ChainMismatchErrorType,\n  ChainNotFoundError,\n  type ChainNotFoundErrorType,\n} from '../../errors/chain.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\n\nexport type AssertCurrentChainParameters = {\n  chain?: Chain | undefined\n  currentChainId: number\n}\n\nexport type AssertCurrentChainErrorType =\n  | ChainNotFoundErrorType\n  | ChainMismatchErrorType\n  | ErrorType\n\nexport function assertCurrentChain({\n  chain,\n  currentChainId,\n}: AssertCurrentChainParameters): void {\n  if (!chain) throw new ChainNotFoundError()\n  if (currentChainId !== chain.id)\n    throw new ChainMismatchError({ chain, currentChainId })\n}\n","import type { Account } from '../../accounts/types.js'\nimport type { SendTransactionParameters } from '../../actions/wallet/sendTransaction.js'\nimport type { BaseError } from '../../errors/base.js'\nimport { UnknownNodeError } from '../../errors/node.js'\nimport {\n  TransactionExecutionError,\n  type TransactionExecutionErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\n\nimport {\n  type GetNodeErrorParameters,\n  type GetNodeErrorReturnType,\n  getNodeError,\n} from './getNodeError.js'\n\nexport type GetTransactionErrorParameters = Omit<\n  SendTransactionParameters,\n  'account' | 'chain'\n> & {\n  account: Account | null\n  chain?: Chain | undefined\n  docsPath?: string | undefined\n}\n\nexport type GetTransactionErrorReturnType<cause = ErrorType> = Omit<\n  TransactionExecutionErrorType,\n  'cause'\n> & { cause: cause | GetNodeErrorReturnType }\n\nexport function getTransactionError<err extends ErrorType<string>>(\n  err: err,\n  { docsPath, ...args }: GetTransactionErrorParameters,\n): GetTransactionErrorReturnType<err> {\n  const cause = (() => {\n    const cause = getNodeError(\n      err as {} as BaseError,\n      args as GetNodeErrorParameters,\n    )\n    if (cause instanceof UnknownNodeError) return err as {} as BaseError\n    return cause\n  })()\n  return new TransactionExecutionError(cause, {\n    docsPath,\n    ...args,\n  }) as GetTransactionErrorReturnType<err>\n}\n","import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { SignTransactionErrorType } from '../../accounts/utils/signTransaction.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  AccountNotFoundError,\n  type AccountNotFoundErrorType,\n  AccountTypeNotSupportedError,\n  type AccountTypeNotSupportedErrorType,\n} from '../../errors/account.js'\nimport { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type { GetTransactionRequestKzgParameter } from '../../types/kzg.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport {\n  type RecoverAuthorizationAddressErrorType,\n  recoverAuthorizationAddress,\n} from '../../utils/authorization/recoverAuthorizationAddress.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type AssertCurrentChainErrorType,\n  assertCurrentChain,\n} from '../../utils/chain/assertCurrentChain.js'\nimport {\n  type GetTransactionErrorReturnType,\n  getTransactionError,\n} from '../../utils/errors/getTransactionError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { LruMap } from '../../utils/lru.js'\nimport {\n  type AssertRequestErrorType,\n  type AssertRequestParameters,\n  assertRequest,\n} from '../../utils/transaction/assertRequest.js'\nimport { type GetChainIdErrorType, getChainId } from '../public/getChainId.js'\nimport {\n  defaultParameters,\n  type PrepareTransactionRequestErrorType,\n  prepareTransactionRequest,\n} from './prepareTransactionRequest.js'\nimport {\n  type SendRawTransactionErrorType,\n  sendRawTransaction,\n} from './sendRawTransaction.js'\n\nconst supportsWalletNamespace = new LruMap<boolean>(128)\n\nexport type SendTransactionRequest<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  ///\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'> &\n  GetTransactionRequestKzgParameter\n\nexport type SendTransactionParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  request extends SendTransactionRequest<\n    chain,\n    chainOverride\n  > = SendTransactionRequest<chain, chainOverride>,\n> = request &\n  GetAccountParameter<account, Account | Address, true, true> &\n  GetChainParameter<chain, chainOverride> &\n  GetTransactionRequestKzgParameter<request>\n\nexport type SendTransactionReturnType = Hash\n\nexport type SendTransactionErrorType =\n  | ParseAccountErrorType\n  | GetTransactionErrorReturnType<\n      | AccountNotFoundErrorType\n      | AccountTypeNotSupportedErrorType\n      | AssertCurrentChainErrorType\n      | AssertRequestErrorType\n      | GetChainIdErrorType\n      | PrepareTransactionRequestErrorType\n      | SendRawTransactionErrorType\n      | RecoverAuthorizationAddressErrorType\n      | SignTransactionErrorType\n      | RequestErrorType\n    >\n  | ErrorType\n\n/**\n * Creates, signs, and sends a new transaction to the network.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendTransaction\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)\n *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)\n *\n * @param client - Client to use\n * @param parameters - {@link SendTransactionParameters}\n * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link SendTransactionReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const hash = await sendTransaction(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { sendTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const hash = await sendTransaction(client, {\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n */\nexport async function sendTransaction<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  const request extends SendTransactionRequest<chain, chainOverride>,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SendTransactionParameters<chain, account, chainOverride, request>,\n): Promise<SendTransactionReturnType> {\n  const {\n    account: account_ = client.account,\n    chain = client.chain,\n    accessList,\n    authorizationList,\n    blobs,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    type,\n    value,\n    ...rest\n  } = parameters\n\n  if (typeof account_ === 'undefined')\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/sendTransaction',\n    })\n  const account = account_ ? parseAccount(account_) : null\n\n  try {\n    assertRequest(parameters as AssertRequestParameters)\n\n    const to = await (async () => {\n      // If `to` exists on the parameters, use that.\n      if (parameters.to) return parameters.to\n\n      // If `to` is null, we are sending a deployment transaction.\n      if (parameters.to === null) return undefined\n\n      // If no `to` exists, and we are sending a EIP-7702 transaction, use the\n      // address of the first authorization in the list.\n      if (authorizationList && authorizationList.length > 0)\n        return await recoverAuthorizationAddress({\n          authorization: authorizationList[0],\n        }).catch(() => {\n          throw new BaseError(\n            '`to` is required. Could not infer from `authorizationList`.',\n          )\n        })\n\n      // Otherwise, we are sending a deployment transaction.\n      return undefined\n    })()\n\n    if (account?.type === 'json-rpc' || account === null) {\n      let chainId: number | undefined\n      if (chain !== null) {\n        chainId = await getAction(client, getChainId, 'getChainId')({})\n        assertCurrentChain({\n          currentChainId: chainId,\n          chain,\n        })\n      }\n\n      const chainFormat = client.chain?.formatters?.transactionRequest?.format\n      const format = chainFormat || formatTransactionRequest\n\n      const request = format(\n        {\n          // Pick out extra data that might exist on the chain's transaction request type.\n          ...extract(rest, { format: chainFormat }),\n          accessList,\n          account,\n          authorizationList,\n          blobs,\n          chainId,\n          data,\n          gas,\n          gasPrice,\n          maxFeePerBlobGas,\n          maxFeePerGas,\n          maxPriorityFeePerGas,\n          nonce,\n          to,\n          type,\n          value,\n        } as TransactionRequest,\n        'sendTransaction',\n      )\n\n      const isWalletNamespaceSupported = supportsWalletNamespace.get(client.uid)\n      const method = isWalletNamespaceSupported\n        ? 'wallet_sendTransaction'\n        : 'eth_sendTransaction'\n\n      try {\n        return await client.request(\n          {\n            method,\n            params: [request],\n          },\n          { retryCount: 0 },\n        )\n      } catch (e) {\n        if (isWalletNamespaceSupported === false) throw e\n\n        const error = e as BaseError\n        // If the transport does not support the method or input, attempt to use the\n        // `wallet_sendTransaction` method.\n        if (\n          error.name === 'InvalidInputRpcError' ||\n          error.name === 'InvalidParamsRpcError' ||\n          error.name === 'MethodNotFoundRpcError' ||\n          error.name === 'MethodNotSupportedRpcError'\n        ) {\n          return await client\n            .request(\n              {\n                method: 'wallet_sendTransaction',\n                params: [request],\n              },\n              { retryCount: 0 },\n            )\n            .then((hash) => {\n              supportsWalletNamespace.set(client.uid, true)\n              return hash\n            })\n            .catch((e) => {\n              const walletNamespaceError = e as BaseError\n              if (\n                walletNamespaceError.name === 'MethodNotFoundRpcError' ||\n                walletNamespaceError.name === 'MethodNotSupportedRpcError'\n              ) {\n                supportsWalletNamespace.set(client.uid, false)\n                throw error\n              }\n\n              throw walletNamespaceError\n            })\n        }\n\n        throw error\n      }\n    }\n\n    if (account?.type === 'local') {\n      // Prepare the request for signing (assign appropriate fees, etc.)\n      const request = await getAction(\n        client,\n        prepareTransactionRequest,\n        'prepareTransactionRequest',\n      )({\n        account,\n        accessList,\n        authorizationList,\n        blobs,\n        chain,\n        data,\n        gas,\n        gasPrice,\n        maxFeePerBlobGas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        nonceManager: account.nonceManager,\n        parameters: [...defaultParameters, 'sidecars'],\n        type,\n        value,\n        ...rest,\n        to,\n      } as any)\n\n      const serializer = chain?.serializers?.transaction\n      const serializedTransaction = (await account.signTransaction(request, {\n        serializer,\n      })) as Hash\n      return await getAction(\n        client,\n        sendRawTransaction,\n        'sendRawTransaction',\n      )({\n        serializedTransaction,\n      })\n    }\n\n    if (account?.type === 'smart')\n      throw new AccountTypeNotSupportedError({\n        metaMessages: [\n          'Consider using the `sendUserOperation` Action instead.',\n        ],\n        docsPath: '/docs/actions/bundler/sendUserOperation',\n        type: 'smart',\n      })\n\n    throw new AccountTypeNotSupportedError({\n      docsPath: '/docs/actions/wallet/sendTransaction',\n      type: (account as any)?.type,\n    })\n  } catch (err) {\n    if (err instanceof AccountTypeNotSupportedError) throw err\n    throw getTransactionError(err as BaseError, {\n      ...parameters,\n      account,\n      chain: parameters.chain || undefined,\n    })\n  }\n}\n","import type { Abi, Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  AccountNotFoundError,\n  type AccountNotFoundErrorType,\n} from '../../errors/account.js'\nimport type { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n  ContractFunctionParameters,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { Prettify, UnionEvaluate, UnionOmit } from '../../types/utils.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  type EncodeFunctionDataParameters,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../utils/errors/getContractError.js'\nimport type { FormattedTransactionRequest } from '../../utils/formatters/transactionRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport type { GetMutabilityAwareValue } from '../public/simulateContract.js'\nimport {\n  type SendTransactionErrorType,\n  type SendTransactionReturnType,\n  sendTransaction,\n} from './sendTransaction.js'\nimport type { sendTransactionSync } from './sendTransactionSync.js'\n\nexport type WriteContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  ///\n  allFunctionNames = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = ContractFunctionParameters<\n  abi,\n  'nonpayable' | 'payable',\n  functionName,\n  args,\n  false,\n  allFunctionNames\n> &\n  GetChainParameter<chain, chainOverride> &\n  Prettify<\n    GetAccountParameter<account, Account | Address, true, true> &\n      GetMutabilityAwareValue<\n        abi,\n        'nonpayable' | 'payable',\n        functionName,\n        FormattedTransactionRequest<derivedChain>['value'],\n        args\n      > & {\n        /** Data to append to the end of the calldata. Useful for adding a [\"domain\" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f). */\n        dataSuffix?: Hex | undefined\n      }\n  > &\n  UnionEvaluate<\n    UnionOmit<\n      FormattedTransactionRequest<derivedChain>,\n      'data' | 'from' | 'to' | 'value'\n    >\n  >\n\nexport type WriteContractReturnType = SendTransactionReturnType\n\nexport type WriteContractErrorType =\n  | EncodeFunctionDataErrorType\n  | AccountNotFoundErrorType\n  | ParseAccountErrorType\n  | GetContractErrorReturnType<SendTransactionErrorType>\n  | ErrorType\n\n/**\n * Executes a write function on a contract.\n *\n * - Docs: https://viem.sh/docs/contract/writeContract\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts\n *\n * A \"write\" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms) is needed to be broadcast in order to change the state.\n *\n * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * __Warning: The `write` internally sends a transaction – it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract#usage) before you execute it.__\n *\n * @param client - Client to use\n * @param parameters - {@link WriteContractParameters}\n * @returns A [Transaction Hash](https://viem.sh/docs/glossary/terms#hash). {@link WriteContractReturnType}\n *\n * @example\n * import { createWalletClient, custom, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { writeContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const hash = await writeContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n *   functionName: 'mint',\n *   args: [69420],\n * })\n *\n * @example\n * // With Validation\n * import { createWalletClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateContract, writeContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const { request } = await simulateContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n *   functionName: 'mint',\n *   args: [69420],\n * }\n * const hash = await writeContract(client, request)\n */\nexport async function writeContract<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainOverride extends Chain | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: WriteContractParameters<\n    abi,\n    functionName,\n    args,\n    chain,\n    account,\n    chainOverride\n  >,\n): Promise<WriteContractReturnType> {\n  return writeContract.internal(\n    client,\n    sendTransaction,\n    'sendTransaction',\n    parameters,\n  ) as never\n}\n\nexport namespace writeContract {\n  export async function internal<\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n    const abi extends Abi | readonly unknown[],\n    functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n    args extends ContractFunctionArgs<\n      abi,\n      'nonpayable' | 'payable',\n      functionName\n    >,\n    chainOverride extends Chain | undefined,\n  >(\n    client: Client<Transport, chain, account>,\n    actionFn: typeof sendTransaction | typeof sendTransactionSync,\n    name: 'sendTransaction' | 'sendTransactionSync',\n    parameters: WriteContractParameters<\n      abi,\n      functionName,\n      args,\n      chain,\n      account,\n      chainOverride\n    >,\n  ) {\n    const {\n      abi,\n      account: account_ = client.account,\n      address,\n      args,\n      dataSuffix,\n      functionName,\n      ...request\n    } = parameters as WriteContractParameters\n\n    if (typeof account_ === 'undefined')\n      throw new AccountNotFoundError({\n        docsPath: '/docs/contract/writeContract',\n      })\n    const account = account_ ? parseAccount(account_) : null\n\n    const data = encodeFunctionData({\n      abi,\n      args,\n      functionName,\n    } as EncodeFunctionDataParameters)\n\n    try {\n      return await getAction(\n        client,\n        actionFn as never,\n        name,\n      )({\n        data: `${data}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,\n        to: address,\n        account,\n        ...request,\n      })\n    } catch (error) {\n      throw getContractError(error as BaseError, {\n        abi,\n        address,\n        args,\n        docsPath: '/docs/contract/writeContract',\n        functionName,\n        sender: account?.address,\n      })\n    }\n  }\n}\n"],"names":[],"mappings":"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"}