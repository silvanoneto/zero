module.exports=[760912,a=>{"use strict";var b=a.i(602383),c=a.i(346280),d=a.i(109450),e=a.i(135323),f=a.i(94702),g=a.i(109260),h=a.i(883148),i=a.i(447649),j=a.i(922848),k=a.i(675529),l=a.i(37252),m=a.i(321590),n=a.i(898965),o=a.i(473439),p=a.i(353292),q=a.i(977601),r=a.i(252271),s=a.i(129286);let t={convertEVMChainIdToCoinType(a){if(a>=0x80000000)throw Error("Invalid chainId");return(0x80000000|a)>>>0}};var u=a.i(82228),v=a.i(929581),w=a.i(667625);let x=(0,r.proxy)({suggestions:[],loading:!1}),y=(0,v.withErrorBoundary)({state:x,subscribe:a=>(0,r.subscribe)(x,()=>a(x)),subscribeKey:(a,b)=>(0,s.subscribeKey)(x,a,b),async resolveName(a){try{return await o.BlockchainApiController.lookupEnsName(a)}catch(a){throw Error(a?.reasons?.[0]?.description||"Error resolving name")}},async isNameRegistered(a){try{return await o.BlockchainApiController.lookupEnsName(a),!0}catch{return!1}},async getSuggestions(a){try{return x.loading=!0,x.suggestions=[],x.suggestions=(await o.BlockchainApiController.getEnsNameSuggestions(a)).suggestions||[],x.suggestions}catch(a){throw Error(y.parseEnsApiError(a,"Error fetching name suggestions"))}finally{x.loading=!1}},async getNamesForAddress(a){try{if(!b.ChainController.state.activeCaipNetwork)return[];let c=u.StorageUtil.getEnsFromCacheForAddress(a);if(c)return c;let d=await o.BlockchainApiController.reverseLookupEnsName({address:a});return u.StorageUtil.updateEnsCache({address:a,ens:d,timestamp:Date.now()}),d}catch(a){throw Error(y.parseEnsApiError(a,"Error fetching names for address"))}},async registerName(a){let e=b.ChainController.state.activeCaipNetwork,f=b.ChainController.getAccountData(e?.chainNamespace)?.address,g=d.ConnectorController.getAuthConnector();if(!e)throw Error("Network not found");if(!f||!g)throw Error("Address or auth connector not found");x.loading=!0;try{let d=JSON.stringify({name:a,attributes:{},timestamp:Math.floor(Date.now()/1e3)});w.RouterController.pushTransactionStack({onCancel(){w.RouterController.replace("RegisterAccountName")}});let g=await c.ConnectionController.signMessage(d);x.loading=!1;let h=e.id;if(!h)throw Error("Network not found");let i=t.convertEVMChainIdToCoinType(Number(h));await o.BlockchainApiController.registerEnsName({coinType:i,address:f,signature:g,message:d}),b.ChainController.setAccountProp("profileName",a,e.chainNamespace),u.StorageUtil.updateEnsCache({address:f,ens:[{name:a,registered_at:new Date().toISOString(),updated_at:void 0,addresses:{},attributes:[]}],timestamp:Date.now()}),w.RouterController.replace("RegisterAccountNameSuccess")}catch(c){let b=y.parseEnsApiError(c,`Error registering name ${a}`);throw w.RouterController.replace("RegisterAccountName"),Error(b)}finally{x.loading=!1}},validateName:a=>/^[a-zA-Z0-9-]{4,}$/u.test(a),parseEnsApiError:(a,b)=>a?.reasons?.[0]?.description||b});var z=a.i(242528),A=a.i(786183);let B={id:"2b92315d-eab7-5bef-84fa-089a131333f5",name:"USD Coin",symbol:"USDC",networks:[{name:"ethereum-mainnet",display_name:"Ethereum",chain_id:"1",contract_address:"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"},{name:"polygon-mainnet",display_name:"Polygon",chain_id:"137",contract_address:"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"}]},C={id:"USD",payment_method_limits:[{id:"card",min:"10.00",max:"7500.00"},{id:"ach_bank_account",min:"10.00",max:"25000.00"}]},D={providers:q.ONRAMP_PROVIDERS,selectedProvider:null,error:null,purchaseCurrency:B,paymentCurrency:C,purchaseCurrencies:[B],paymentCurrencies:[],quotesLoading:!1},E=(0,r.proxy)(D),F=(0,v.withErrorBoundary)({state:E,subscribe:a=>(0,r.subscribe)(E,()=>a(E)),subscribeKey:(a,b)=>(0,s.subscribeKey)(E,a,b),setSelectedProvider(a){if(a&&"meld"===a.name){let c=b.ChainController.state.activeChain,d=c===h.ConstantsUtil.CHAIN.SOLANA?"SOL":"USDC",e=c?b.ChainController.state.chains.get(c)?.accountState?.address??"":"",g=new URL(a.url);g.searchParams.append("publicKey",q.MELD_PUBLIC_KEY),g.searchParams.append("destinationCurrencyCode",d),g.searchParams.append("walletAddress",e),g.searchParams.append("externalCustomerId",f.OptionsController.state.projectId),E.selectedProvider={...a,url:g.toString()}}else E.selectedProvider=a},setOnrampProviders(a){Array.isArray(a)&&a.every(a=>"string"==typeof a)?E.providers=q.ONRAMP_PROVIDERS.filter(b=>a.includes(b.name)):E.providers=[]},setPurchaseCurrency(a){E.purchaseCurrency=a},setPaymentCurrency(a){E.paymentCurrency=a},setPurchaseAmount(a){F.state.purchaseAmount=a},setPaymentAmount(a){F.state.paymentAmount=a},async getAvailableCurrencies(){let a=await o.BlockchainApiController.getOnrampOptions();E.purchaseCurrencies=a.purchaseCurrencies,E.paymentCurrencies=a.paymentCurrencies,E.paymentCurrency=a.paymentCurrencies[0]||C,E.purchaseCurrency=a.purchaseCurrencies[0]||B,await m.ApiController.fetchCurrencyImages(a.paymentCurrencies.map(a=>a.id)),await m.ApiController.fetchTokenImages(a.purchaseCurrencies.map(a=>a.symbol))},async getQuote(){E.quotesLoading=!0;try{let a=await o.BlockchainApiController.getOnrampQuote({purchaseCurrency:E.purchaseCurrency,paymentCurrency:E.paymentCurrency,amount:E.paymentAmount?.toString()||"0",network:E.purchaseCurrency?.symbol});return E.quotesLoading=!1,E.purchaseAmount=Number(a?.purchaseAmount.amount),a}catch(a){return E.error=a.message,E.quotesLoading=!1,null}finally{E.quotesLoading=!1}},resetState(){E.selectedProvider=null,E.error=null,E.purchaseCurrency=B,E.paymentCurrency=C,E.purchaseCurrencies=[B],E.paymentCurrencies=[],E.paymentAmount=void 0,E.purchaseAmount=void 0,E.quotesLoading=!1}});var G=a.i(890447),H=a.i(284799),I=a.i(720214),J=a.i(411210),K=a.i(531657),L=a.i(371188);let M={solana:["solana_signMessage","solana_signTransaction","solana_requestAccounts","solana_getAccounts","solana_signAllTransactions","solana_signAndSendTransaction"],eip155:["eth_accounts","eth_requestAccounts","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","eth_sendTransaction","personal_sign","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode","wallet_getCallsStatus","wallet_showCallsStatus","wallet_sendCalls","wallet_getCapabilities","wallet_grantPermissions","wallet_revokePermissions","wallet_getAssets"],bip122:["sendTransfer","signMessage","signPsbt","getAccountAddresses"]},N={RPC_ERROR_CODE:{USER_REJECTED:5e3,USER_REJECTED_METHODS:5002},getMethodsByChainNamespace:a=>M[a]||[],createDefaultNamespace(a){return{methods:this.getMethodsByChainNamespace(a),events:["accountsChanged","chainChanged"],chains:[],rpcMap:{}}},applyNamespaceOverrides(a,b){if(!b)return{...a};let c={...a},d=new Set;if(b.methods&&Object.keys(b.methods).forEach(a=>d.add(a)),b.chains&&Object.keys(b.chains).forEach(a=>d.add(a)),b.events&&Object.keys(b.events).forEach(a=>d.add(a)),b.rpcMap&&Object.keys(b.rpcMap).forEach(a=>{let[b]=a.split(":");b&&d.add(b)}),d.forEach(a=>{c[a]||(c[a]=this.createDefaultNamespace(a))}),b.methods&&Object.entries(b.methods).forEach(([a,b])=>{c[a]&&(c[a].methods=b)}),b.chains&&Object.entries(b.chains).forEach(([a,b])=>{c[a]&&(c[a].chains=b)}),b.events&&Object.entries(b.events).forEach(([a,b])=>{c[a]&&(c[a].events=b)}),b.rpcMap){let a=new Set;Object.entries(b.rpcMap).forEach(([b,d])=>{let[e,f]=b.split(":");e&&f&&c[e]&&(c[e].rpcMap||(c[e].rpcMap={}),a.has(e)||(c[e].rpcMap={},a.add(e)),c[e].rpcMap[f]=d)})}return c},createNamespaces(a,b){let c=a.reduce((a,b)=>{let{id:c,chainNamespace:d,rpcUrls:e}=b,f=e.default.http[0];a[d]||(a[d]=this.createDefaultNamespace(d));let g=`${d}:${c}`,h=a[d];switch(h.chains.push(g),g){case"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp":h.chains.push("solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ");break;case"solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1":h.chains.push("solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K")}return h?.rpcMap&&f&&(h.rpcMap[c]=f),a},{});return this.applyNamespaceOverrides(c,b)},resolveReownName:async a=>{let b=await y.resolveName(a),c=Object.values(b?.addresses)||[];return c[0]?.address||!1},getChainsFromNamespaces:(a={})=>Object.values(a).flatMap(a=>Array.from(new Set([...a.chains||[],...a.accounts.map(a=>{let[b,c]=a.split(":");return`${b}:${c}`})]))),isSessionEventData:a=>"object"==typeof a&&null!==a&&"id"in a&&"topic"in a&&"params"in a&&"object"==typeof a.params&&null!==a.params&&"chainId"in a.params&&"event"in a.params&&"object"==typeof a.params.event&&null!==a.params.event,isUserRejectedRequestError(a){try{if("object"==typeof a&&null!==a){let b="number"==typeof a.code,c=b&&a.code===N.RPC_ERROR_CODE.USER_REJECTED_METHODS,d=b&&a.code===N.RPC_ERROR_CODE.USER_REJECTED;return c||d}return!1}catch{return!1}},isOriginAllowed(a,b,c){for(let d of[...b,...c])if(d.includes("*")){let b=d.replace(/[.*+?^${}()|[\]\\]/gu,"\\$&");if(RegExp(`^${b.replace(/\\\*/gu,".*")}$`,"u").test(a))return!0}else try{if(new URL(d).origin===a)return!0}catch(b){if(d===a)return!0}return!1},listenWcProvider({universalProvider:a,namespace:b,onConnect:c,onDisconnect:d,onAccountsChanged:e,onChainChanged:f,onDisplayUri:g}){c&&a.on("connect",()=>{c(N.getWalletConnectAccounts(a,b))}),d&&a.on("disconnect",()=>{d()}),e&&a.on("accountsChanged",c=>{try{let d=a.session?.namespaces?.[b]?.accounts||[],f=a.rpcProviders?.[b]?.getDefaultChain(),g=c.map(a=>{let c=d.find(c=>c.includes(`${b}:${f}:${a}`));if(!c)return;let{chainId:e,chainNamespace:g}=j.ParseUtil.parseCaipAddress(c);return{address:a,chainId:e,chainNamespace:g}}).filter(a=>void 0!==a);g.length>0&&e(g)}catch(a){console.warn("Failed to parse accounts for namespace on accountsChanged event",b,c,a)}}),f&&a.on("chainChanged",a=>{f(a)}),g&&a.on("display_uri",a=>{g(a)})},getWalletConnectAccounts(a,b){let c=new Set,d=a?.session?.namespaces?.[b]?.accounts?.map(a=>j.ParseUtil.parseCaipAddress(a)).filter(({address:a})=>!c.has(a.toLowerCase())&&(c.add(a.toLowerCase()),!0));return d&&d.length>0?d:[]}};var O=a.i(435044);a.i(287862),a.i(974991);var P=a.i(951028);a.i(639170);var Q=a.i(638183),R=a.i(351761),S=a.i(680704);new AbortController;let T={UNAUTHORIZED_DOMAIN_NOT_ALLOWED:{message:"Unauthorized: origin not allowed",alertErrorKey:"ORIGIN_NOT_ALLOWED"},JWT_VALIDATION_ERROR:{message:"JWT validation error: JWT Token is not yet valid",alertErrorKey:"JWT_TOKEN_NOT_VALID"},INVALID_KEY:{message:"Unauthorized: invalid key",alertErrorKey:"INVALID_PROJECT_ID"}},U={SWITCH_NETWORK_NOT_FOUND:{code:"APKT001",displayMessage:"Network Not Found",debugMessage:"The specified network is not recognized. Please ensure it is included in the `networks` array of your `createAppKit` configuration."},ORIGIN_NOT_ALLOWED:{code:"APKT002",displayMessage:"Invalid App Configuration",debugMessage:()=>`The origin ${(0,S.isSafe)()?window.origin:"unknown"} is not in your allow list. Please update your allowed domains at https://dashboard.reown.com. [PID: ${f.OptionsController.state.projectId}]`},IFRAME_LOAD_FAILED:{code:"APKT003",displayMessage:"Network Error: Wallet Load Failed",debugMessage:()=>"Failed to load the embedded wallet. This may be due to network issues or server downtime. Please check your network connection and try again shortly. Contact support if the issue persists."},IFRAME_REQUEST_TIMEOUT:{code:"APKT004",displayMessage:"Wallet Request Timeout",debugMessage:()=>"The request to the embedded wallet timed out. Please check your network connection and try again shortly. Contact support if the issue persists."},UNVERIFIED_DOMAIN:{code:"APKT005",displayMessage:"Unverified Domain",debugMessage:()=>"Embedded wallet load failed. Ensure your domain is verified in https://dashboard.reown.com."},JWT_TOKEN_NOT_VALID:{code:"APKT006",displayMessage:"Session Expired",debugMessage:"Your session is invalid or expired. Please check your systemâ€™s date and time settings, then reconnect."},INVALID_PROJECT_ID:{code:"APKT007",displayMessage:"Invalid Project ID",debugMessage:"The specified project ID is invalid. Please visit https://dashboard.reown.com to obtain a valid project ID."},PROJECT_ID_NOT_CONFIGURED:{code:"APKT008",displayMessage:"Project ID Missing",debugMessage:"No project ID is configured. You can create and configure a project ID at https://dashboard.reown.com."},SERVER_ERROR_APP_CONFIGURATION:{code:"APKT009",displayMessage:"Server Error",debugMessage:a=>`Unable to fetch App Configuration. ${a}. Please check your network connection and try again shortly. Contact support if the issue persists.`},RATE_LIMITED_APP_CONFIGURATION:{code:"APKT010",displayMessage:"Rate Limited",debugMessage:"You have been rate limited while retrieving App Configuration. Please wait a few minutes and try again. Contact support if the issue persists."}},V={debugMessage:a=>`[Reown Config Notice] ${a}`},W={code:"APKTW001",displayMessage:"Inactive Namespace Not Connected",debugMessage:(a,b)=>`An error occurred while connecting an inactive namespace ${a}: "${b}"`};var X=a.i(217327),Y=a.i(31620);let Z={createLogger(a,b="error"){let c=(0,Y.getDefaultLoggerOptions)({level:b}),{logger:d}=(0,Y.generatePlatformLogger)({opts:c});return d.error=(...b)=>{for(let c of b)if(c instanceof Error)return void a(c,...b);a(void 0,...b)},d}},$={TOKEN_ADDRESSES_BY_SYMBOL:{USDC:{8453:"0x833589fcd6edb6e08f4c7c32d4f71b54bda02913",84532:"0x036CbD53842c5426634e7929541eC2318f3dCF7e"}},getTokenSymbolByAddress(a){if(!a)return;let[b]=Object.entries($.TOKEN_ADDRESSES_BY_SYMBOL).find(([b,c])=>Object.values(c).includes(a))??[];return b}};var _=a.i(7174);let aa=function(a){if(a.length>=255)throw TypeError("Alphabet too long");let b=new Uint8Array(256);for(let a=0;a<b.length;a++)b[a]=255;for(let c=0;c<a.length;c++){let d=a.charAt(c),e=d.charCodeAt(0);if(255!==b[e])throw TypeError(d+" is ambiguous");b[e]=c}let c=a.length,d=a.charAt(0),e=Math.log(c)/Math.log(256),f=Math.log(256)/Math.log(c);function g(a){if("string"!=typeof a)throw TypeError("Expected String");if(0===a.length)return new Uint8Array;let f=0,g=0,h=0;for(;a[f]===d;)g++,f++;let i=(a.length-f)*e+1>>>0,j=new Uint8Array(i);for(;f<a.length;){let d=a.charCodeAt(f);if(d>255)return;let e=b[d];if(255===e)return;let g=0;for(let a=i-1;(0!==e||g<h)&&-1!==a;a--,g++)e+=c*j[a]>>>0,j[a]=e%256>>>0,e=e/256>>>0;if(0!==e)throw Error("Non-zero carry");h=g,f++}let k=i-h;for(;k!==i&&0===j[k];)k++;let l=new Uint8Array(g+(i-k)),m=g;for(;k!==i;)l[m++]=j[k++];return l}return{encode:function(b){if(b instanceof Uint8Array||(ArrayBuffer.isView(b)?b=new Uint8Array(b.buffer,b.byteOffset,b.byteLength):Array.isArray(b)&&(b=Uint8Array.from(b))),!(b instanceof Uint8Array))throw TypeError("Expected Uint8Array");if(0===b.length)return"";let e=0,g=0,h=0,i=b.length;for(;h!==i&&0===b[h];)h++,e++;let j=(i-h)*f+1>>>0,k=new Uint8Array(j);for(;h!==i;){let a=b[h],d=0;for(let b=j-1;(0!==a||d<g)&&-1!==b;b--,d++)a+=256*k[b]>>>0,k[b]=a%c>>>0,a=a/c>>>0;if(0!==a)throw Error("Non-zero carry");g=d,h++}let l=j-g;for(;l!==j&&0===k[l];)l++;let m=d.repeat(e);for(;l<j;++l)m+=a.charAt(k[l]);return m},decodeUnsafe:g,decode:function(a){let b=g(a);if(b)return b;throw Error("Non-base"+c+" character")}}}("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");var ab=a.i(221570),ac=a.i(916451);let ad=[h.ConstantsUtil.CONNECTOR_ID.AUTH,h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT];class ae{constructor(a){this.availableConnectors=[],this.availableConnections=[],this.providerHandlers={},this.eventListeners=new Map,this.getCaipNetworks=a=>b.ChainController.getCaipNetworks(a),this.getConnectorId=a=>d.ConnectorController.getConnectorId(a),a&&this.construct(a)}construct(a){this.projectId=a.projectId,this.namespace=a.namespace,this.adapterType=a.adapterType}get connectors(){return this.availableConnectors}get connections(){return this.availableConnections}get networks(){return this.getCaipNetworks(this.namespace)}onAuthConnected({accounts:a,chainId:b}){let c=this.getCaipNetworks().filter(a=>a.chainNamespace===this.namespace).find(a=>a.id.toString()===b?.toString());a&&c&&this.addConnection({connectorId:h.ConstantsUtil.CONNECTOR_ID.AUTH,accounts:a,caipNetwork:c})}setAuthProvider(a){a.onConnect(this.onAuthConnected.bind(this)),a.onSocialConnected(this.onAuthConnected.bind(this)),this.addConnector({id:h.ConstantsUtil.CONNECTOR_ID.AUTH,type:"AUTH",name:h.ConstantsUtil.CONNECTOR_NAMES.AUTH,provider:a,imageId:void 0,chain:this.namespace,chains:[]})}addConnector(...a){let b=new Set;this.availableConnectors=[...a,...this.availableConnectors].filter(a=>!b.has(a.id)&&(b.add(a.id),!0)),this.emit("connectors",this.availableConnectors)}addConnection(...a){let b=new Set;this.availableConnections=[...a,...this.availableConnections].filter(a=>!b.has(a.connectorId.toLowerCase())&&(b.add(a.connectorId.toLowerCase()),!0)),this.emit("connections",this.availableConnections)}deleteConnection(a){this.availableConnections=this.availableConnections.filter(b=>b.connectorId.toLowerCase()!==a.toLowerCase()),this.emit("connections",this.availableConnections)}clearConnections(a=!1){this.availableConnections=[],a&&this.emit("connections",this.availableConnections)}setStatus(a,c){b.ChainController.setAccountProp("status",a,c)}on(a,b){this.eventListeners.has(a)||this.eventListeners.set(a,new Set),this.eventListeners.get(a)?.add(b)}off(a,b){let c=this.eventListeners.get(a);c&&c.delete(b)}removeAllEventListeners(){this.eventListeners.forEach(a=>{a.clear()})}emit(a,b){let c=this.eventListeners.get(a);c&&c.forEach(a=>a(b))}async connectWalletConnect(a){try{let a=this.getWalletConnectConnector();return{clientId:(await a.connectWalletConnect()).clientId}}catch(a){if(N.isUserRejectedRequestError(a))throw new ac.UserRejectedRequestError(a);throw a}}async switchNetwork(a){let{caipNetwork:b}=a,c=G.ProviderController.getProviderId(b.chainNamespace),e=G.ProviderController.getProvider(b.chainNamespace);if(!e)throw Error("Provider not found");if("WALLET_CONNECT"===c)return void e.setDefaultChain(b.caipNetworkId);if("AUTH"===c){let a=d.ConnectorController.getAuthConnector()?.provider;if(!a)throw Error("Auth provider not found");let c=(0,O.getPreferredAccountType)(b.chainNamespace);await a.switchNetwork({chainId:b.caipNetworkId});let e=await a.getUser({chainId:b.caipNetworkId,preferredAccountType:c});this.emit("switchNetwork",e)}}getWalletConnectConnector(){let a=this.connectors.find(a=>"walletConnect"===a.id);if(!a)throw Error("WalletConnectConnector not found");return a}onConnect(a,b){if(a.length>0){let{address:c,chainId:d}=e.CoreHelperUtil.getAccount(a[0]),f=this.getCaipNetworks().filter(a=>a.chainNamespace===this.namespace).find(a=>a.id.toString()===d?.toString()),g=this.connectors.find(a=>a.id===b);c&&(this.emit("accountChanged",{address:c,chainId:d,connector:g}),this.addConnection({connectorId:b,accounts:a.map(a=>{let{address:b}=e.CoreHelperUtil.getAccount(a);return{address:b}}),caipNetwork:f}))}}onAccountsChanged(a,b,c=!0){if(a.length>0){let{address:c}=e.CoreHelperUtil.getAccount(a[0]),d=this.getConnection({connectorId:b,connections:this.connections,connectors:this.connectors});c&&this.getConnectorId(h.ConstantsUtil.CHAIN.EVM)?.toLowerCase()===b.toLowerCase()&&this.emit("accountChanged",{address:c,chainId:d?.caipNetwork?.id,connector:d?.connector}),this.addConnection({connectorId:b,accounts:a.map(a=>{let{address:b}=e.CoreHelperUtil.getAccount(a);return{address:b}}),caipNetwork:d?.caipNetwork})}else c&&this.onDisconnect(b)}onDisconnect(a){this.removeProviderListeners(a),this.deleteConnection(a),this.getConnectorId(h.ConstantsUtil.CHAIN.EVM)?.toLowerCase()===a.toLowerCase()&&this.emitFirstAvailableConnection(),0===this.connections.length&&this.emit("disconnect")}onChainChanged(a,b){let c="string"==typeof a&&a.startsWith("0x")?parseInt(a,16).toString():a.toString(),d=this.getConnection({connectorId:b,connections:this.connections,connectors:this.connectors}),e=this.getCaipNetworks().filter(a=>a.chainNamespace===this.namespace).find(a=>a.id.toString()===c);d&&this.addConnection({connectorId:b,accounts:d.accounts,caipNetwork:e}),this.getConnectorId(h.ConstantsUtil.CHAIN.EVM)?.toLowerCase()===b.toLowerCase()&&this.emit("switchNetwork",{chainId:c})}listenProviderEvents(a,b){if(ad.includes(a))return;let c=b=>this.onAccountsChanged(b,a),d=b=>this.onChainChanged(b,a),e=()=>this.onDisconnect(a);this.providerHandlers[a]||(b.on("disconnect",e),b.on("accountsChanged",c),b.on("chainChanged",d),this.providerHandlers[a]={provider:b,disconnect:e,accountsChanged:c,chainChanged:d})}removeProviderListeners(a){if(this.providerHandlers[a]){let{provider:b,disconnect:c,accountsChanged:d,chainChanged:e}=this.providerHandlers[a];b.removeListener("disconnect",c),b.removeListener("accountsChanged",d),b.removeListener("chainChanged",e),this.providerHandlers[a]=null}}emitFirstAvailableConnection(){let a=this.getConnection({connections:this.connections,connectors:this.connectors});if(a){let[b]=a.accounts;this.emit("accountChanged",{address:b?.address,chainId:a.caipNetwork?.id,connector:a.connector})}}getConnection({address:a,connectorId:b,connections:c,connectors:d}){if(b){let e=c.find(a=>a.connectorId.toLowerCase()===b.toLowerCase());if(!e)return null;let f=d.find(a=>a.id.toLowerCase()===e.connectorId.toLowerCase()),g=a?e.accounts.find(b=>b.address.toLowerCase()===a.toLowerCase()):e.accounts[0];return{...e,account:g,connector:f}}let e=c.find(a=>a.accounts.length>0&&d.some(b=>b.id.toLowerCase()===a.connectorId.toLowerCase()));if(e){let[a]=e.accounts,b=d.find(a=>a.id.toLowerCase()===e.connectorId.toLowerCase());return{...e,account:a,connector:b}}return null}}class af{constructor({provider:a,namespace:c}){this.id=h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT,this.name="WalletConnect",this.type="WALLET_CONNECT",this.imageId="ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",this.getCaipNetworks=b.ChainController.getCaipNetworks.bind(b.ChainController),this.caipNetworks=this.getCaipNetworks(),this.provider=a,this.chain=c}get chains(){return this.getCaipNetworks()}async connectWalletConnect(){if(!await this.authenticate()){let a=this.getCaipNetworks(),b=f.OptionsController.state.universalProviderConfigOverride,c=N.createNamespaces(a,b);await this.provider.connect({optionalNamespaces:c})}return{clientId:await this.provider.client.core.crypto.getClientId(),session:this.provider.session}}async disconnect(){await this.provider.disconnect()}async authenticate(){let a=this.chains.map(a=>a.caipNetworkId);return I.SIWXUtil.universalProviderAuthenticate({universalProvider:this.provider,chains:a,methods:ag})}}let ag=["eth_accounts","eth_requestAccounts","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","eth_sendTransaction","personal_sign","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode","wallet_getCallsStatus","wallet_sendCalls","wallet_getCapabilities","wallet_grantPermissions","wallet_revokePermissions","wallet_getAssets"];class ah extends ae{async setUniversalProvider(a){if(!this.namespace)throw Error("UniversalAdapter:setUniversalProvider - namespace is required");return this.addConnector(new af({provider:a,caipNetworks:this.getCaipNetworks(),namespace:this.namespace})),Promise.resolve()}async connect(a){return Promise.resolve({id:"WALLET_CONNECT",type:"WALLET_CONNECT",chainId:Number(a.chainId),provider:this.provider,address:""})}async disconnect(){try{let a=this.getWalletConnectConnector();await a.disconnect(),this.emit("disconnect")}catch(a){console.warn("UniversalAdapter:disconnect - error",a)}return{connections:[]}}syncConnections(){return Promise.resolve()}async getAccounts({namespace:a}){let b=this.provider;return Promise.resolve({accounts:(b?.session?.namespaces?.[a]?.accounts?.map(a=>{let[,,b]=a.split(":");return b}).filter((a,b,c)=>c.indexOf(a)===b)||[]).map(b=>e.CoreHelperUtil.createAccount(a,b,"bip122"===a?"payment":"eoa"))})}async syncConnectors(){return Promise.resolve()}async getBalance(a){if(!(a.caipNetwork&&q.ConstantsUtil.BALANCE_SUPPORTED_CHAINS.includes(a.caipNetwork?.chainNamespace))||a.caipNetwork?.testnet)return{balance:"0.00",symbol:a.caipNetwork?.nativeCurrency.symbol||""};let c=b.ChainController.getAccountData();if(c?.balanceLoading&&a.chainId===b.ChainController.state.activeCaipNetwork?.id)return{balance:c?.balance||"0.00",symbol:c?.balanceSymbol||""};let d=(await b.ChainController.fetchTokenBalance()).find(b=>b.chainId===`${a.caipNetwork?.chainNamespace}:${a.chainId}`&&b.symbol===a.caipNetwork?.nativeCurrency.symbol);return{balance:d?.quantity.numeric||"0.00",symbol:d?.symbol||a.caipNetwork?.nativeCurrency.symbol||""}}async signMessage(a){let{provider:c,message:d,address:e}=a;if(!c)throw Error("UniversalAdapter:signMessage - provider is undefined");return{signature:b.ChainController.state.activeCaipNetwork?.chainNamespace===h.ConstantsUtil.CHAIN.SOLANA?(await c.request({method:"solana_signMessage",params:{message:aa.encode(new TextEncoder().encode(d)),pubkey:e}},b.ChainController.state.activeCaipNetwork?.caipNetworkId)).signature:await c.request({method:"personal_sign",params:[d,e]},b.ChainController.state.activeCaipNetwork?.caipNetworkId)}}async estimateGas(){return Promise.resolve({gas:BigInt(0)})}async sendTransaction(){return Promise.resolve({hash:""})}walletGetAssets(a){return Promise.resolve({})}async writeContract(){return Promise.resolve({hash:""})}emitFirstAvailableConnection(){}parseUnits(){return 0n}formatUnits(){return"0"}async getCapabilities(){return Promise.resolve({})}async grantPermissions(){return Promise.resolve({})}async revokePermissions(){return Promise.resolve("0x")}async syncConnection(){return Promise.resolve({id:"WALLET_CONNECT",type:"WALLET_CONNECT",chainId:1,provider:this.provider,address:""})}async switchNetwork(a){let{caipNetwork:b}=a,c=this.getWalletConnectConnector();if(b.chainNamespace===h.ConstantsUtil.CHAIN.EVM)try{await c.provider?.request({method:"wallet_switchEthereumChain",params:[{chainId:(0,ab.toHex)(b.id)}]})}catch(a){if(4902===a.code||32603===a.code||5e3===a.code||a?.data?.originalError?.code===4902)try{await c.provider?.request({method:"wallet_addEthereumChain",params:[{chainId:(0,ab.toHex)(b.id),rpcUrls:[b?.rpcUrls.chainDefault?.http],chainName:b.name,nativeCurrency:b.nativeCurrency,blockExplorerUrls:[b.blockExplorers?.default.url]}]})}catch(a){throw Error("Chain is not supported")}}c.provider.setDefaultChain(b.caipNetworkId)}getWalletConnectProvider(){let a=this.connectors.find(a=>"WALLET_CONNECT"===a.type);return a?.provider}}let ai=["email","socials","swaps","onramp","activity","reownBranding","multiWallet","emailCapture","payWithExchange","payments","reownAuthentication"],aj={email:{apiFeatureName:"social_login",localFeatureName:"email",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:a=>{if(!a?.config)return!1;let b=a.config;return!!a.isEnabled&&b.includes("email")},processFallback:a=>void 0===a?q.ConstantsUtil.DEFAULT_REMOTE_FEATURES.email:!!a},socials:{apiFeatureName:"social_login",localFeatureName:"socials",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:a=>{if(!a?.config)return!1;let b=a.config;return!!a.isEnabled&&b.length>0&&b.filter(a=>"email"!==a)},processFallback:a=>void 0===a?q.ConstantsUtil.DEFAULT_REMOTE_FEATURES.socials:"boolean"==typeof a?!!a&&q.ConstantsUtil.DEFAULT_REMOTE_FEATURES.socials:a},swaps:{apiFeatureName:"swap",localFeatureName:"swaps",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:a=>{if(!a?.config)return!1;let b=a.config;return!!a.isEnabled&&b.length>0&&b},processFallback:a=>void 0===a?q.ConstantsUtil.DEFAULT_REMOTE_FEATURES.swaps:"boolean"==typeof a?!!a&&q.ConstantsUtil.DEFAULT_REMOTE_FEATURES.swaps:a},onramp:{apiFeatureName:"onramp",localFeatureName:"onramp",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:a=>{if(!a?.config)return!1;let b=a.config;return!!a.isEnabled&&b.length>0&&b},processFallback:a=>void 0===a?q.ConstantsUtil.DEFAULT_REMOTE_FEATURES.onramp:"boolean"==typeof a?!!a&&q.ConstantsUtil.DEFAULT_REMOTE_FEATURES.onramp:a},activity:{apiFeatureName:"activity",localFeatureName:"history",returnType:!1,isLegacy:!0,isAvailableOnBasic:!1,processApi:a=>!!a.isEnabled,processFallback:a=>void 0===a?q.ConstantsUtil.DEFAULT_REMOTE_FEATURES.activity:!!a},reownBranding:{apiFeatureName:"reown_branding",localFeatureName:"reownBranding",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:a=>!!a.isEnabled,processFallback:a=>void 0===a?q.ConstantsUtil.DEFAULT_REMOTE_FEATURES.reownBranding:!!a},emailCapture:{apiFeatureName:"email_capture",localFeatureName:"emailCapture",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:a=>a.isEnabled&&(a.config??[]),processFallback:a=>!1},multiWallet:{apiFeatureName:"multi_wallet",localFeatureName:"multiWallet",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:a=>!!a.isEnabled,processFallback:()=>q.ConstantsUtil.DEFAULT_REMOTE_FEATURES.multiWallet},payWithExchange:{apiFeatureName:"fund_from_exchange",localFeatureName:"payWithExchange",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:a=>!!a.isEnabled,processFallback:()=>q.ConstantsUtil.DEFAULT_REMOTE_FEATURES.payWithExchange},payments:{apiFeatureName:"payments",localFeatureName:"payments",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:a=>!!a.isEnabled,processFallback:()=>q.ConstantsUtil.DEFAULT_REMOTE_FEATURES.payments},reownAuthentication:{apiFeatureName:"reown_authentication",localFeatureName:"reownAuthentication",returnType:!1,isLegacy:!1,isAvailableOnBasic:!1,processApi:a=>!!a.isEnabled,processFallback:a=>void 0===a?q.ConstantsUtil.DEFAULT_REMOTE_FEATURES.reownAuthentication:!!a}},ak={localSettingsOverridden:new Set,getApiConfig:(a,b)=>b?.find(b=>b.id===a),addWarning(a,b){if(void 0!==a){let a=aj[b],c=a.isLegacy?`"features.${a.localFeatureName}" (now "${b}")`:`"features.${b}"`;this.localSettingsOverridden.add(c)}},processFeature(a,b,c,d,e){let f=aj[a],g=b[f.localFeatureName];if(e&&!f.isAvailableOnBasic)return!1;if(d){let b=this.getApiConfig(f.apiFeatureName,c);return b?.config===null?this.processFallbackFeature(a,g):!!b?.config&&(void 0!==g&&this.addWarning(g,a),this.processApiFeature(a,b))}return this.processFallbackFeature(a,g)},processApiFeature:(a,b)=>aj[a].processApi(b),processFallbackFeature:(a,b)=>aj[a].processFallback(b),async fetchRemoteFeatures(a){let b=a.basic??!1,c=a.features||{};this.localSettingsOverridden.clear();let d=null,e=!1;try{e=null!=(d=await m.ApiController.fetchProjectConfig())}catch(a){console.warn("[Reown Config] Failed to fetch remote project configuration. Using local/default values.",a)}let f=e&&!b?q.ConstantsUtil.DEFAULT_REMOTE_FEATURES:q.ConstantsUtil.DEFAULT_REMOTE_FEATURES_DISABLED;try{for(let a of ai){let g=this.processFeature(a,c,d,e,b);Object.assign(f,{[a]:g})}}catch(a){return console.warn("[Reown Config] Failed to process the configuration from Cloud. Using default values.",a),q.ConstantsUtil.DEFAULT_REMOTE_FEATURES}if(e&&this.localSettingsOverridden.size>0){let a=`Your local configuration for ${Array.from(this.localSettingsOverridden).join(", ")} was ignored because a remote configuration was successfully fetched. Please manage these features via your project dashboard on dashboard.reown.com.`;l.AlertController.open({debugMessage:V.debugMessage(a)},"warning")}return f}};class al{constructor(a){this.chainNamespaces=[],this.features={},this.remoteFeatures={},this.reportedAlertErrors={},this.getCaipNetwork=(a,c)=>{if(a){let d=b.ChainController.getCaipNetworks(a)?.find(a=>a.id===c);if(d)return d;let e=b.ChainController.getNetworkData(a)?.caipNetwork;if(e)return e;let f=b.ChainController.getRequestedCaipNetworks(a);return f.filter(b=>b.chainNamespace===a)?.[0]}return b.ChainController.state.activeCaipNetwork||this.defaultCaipNetwork},this.getCaipNetworkId=()=>{let a=this.getCaipNetwork();if(a)return a.id},this.getCaipNetworks=a=>b.ChainController.getCaipNetworks(a),this.getActiveChainNamespace=()=>b.ChainController.state.activeChain,this.setRequestedCaipNetworks=(a,c)=>{b.ChainController.setRequestedCaipNetworks(a,c)},this.getApprovedCaipNetworkIds=()=>b.ChainController.getAllApprovedCaipNetworkIds(),this.getCaipAddress=a=>b.ChainController.state.activeChain!==a&&a?b.ChainController.state.chains.get(a)?.accountState?.caipAddress:b.ChainController.state.activeCaipAddress,this.setClientId=a=>{o.BlockchainApiController.setClientId(a)},this.getProvider=a=>G.ProviderController.getProvider(a),this.getProviderType=a=>G.ProviderController.getProviderId(a),this.getPreferredAccountType=a=>(0,O.getPreferredAccountType)(a),this.setCaipAddress=(a,c,d=!1)=>{b.ChainController.setAccountProp("caipAddress",a,c,d),b.ChainController.setAccountProp("address",e.CoreHelperUtil.getPlainAddress(a),c,d)},this.setBalance=(a,c,d)=>{b.ChainController.setAccountProp("balance",a,d),b.ChainController.setAccountProp("balanceSymbol",c,d)},this.setProfileName=(a,c)=>{b.ChainController.setAccountProp("profileName",a,c)},this.setProfileImage=(a,c)=>{b.ChainController.setAccountProp("profileImage",a,c)},this.setUser=(a,c)=>{b.ChainController.setAccountProp("user",a,c)},this.resetAccount=a=>{b.ChainController.resetAccount(a)},this.setCaipNetwork=a=>{b.ChainController.setActiveCaipNetwork(a)},this.setCaipNetworkOfNamespace=(a,c)=>{b.ChainController.setChainNetworkData(c,{caipNetwork:a})},this.setStatus=(a,c)=>{b.ChainController.setAccountProp("status",a,c),d.ConnectorController.isConnected()?u.StorageUtil.setConnectionStatus("connected"):u.StorageUtil.setConnectionStatus("disconnected")},this.getAddressByChainNamespace=a=>b.ChainController.getAccountData(a)?.address,this.setConnectors=a=>{let b=[...d.ConnectorController.state.allConnectors,...a];d.ConnectorController.setConnectors(b)},this.setConnections=(a,b)=>{u.StorageUtil.setConnections(a,b),c.ConnectionController.setConnections(a,b)},this.fetchIdentity=a=>o.BlockchainApiController.fetchIdentity(a),this.getReownName=a=>y.getNamesForAddress(a),this.getConnectors=()=>d.ConnectorController.getConnectors(),this.getConnectorImage=a=>n.AssetUtil.getConnectorImage(a),this.getConnections=a=>this.remoteFeatures.multiWallet?p.ConnectionControllerUtil.getConnectionsData(a).connections:(l.AlertController.open(h.ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,"info"),[]),this.getRecentConnections=a=>this.remoteFeatures.multiWallet?p.ConnectionControllerUtil.getConnectionsData(a).recentConnections:(l.AlertController.open(h.ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,"info"),[]),this.switchConnection=async a=>{this.remoteFeatures.multiWallet?await c.ConnectionController.switchConnection(a):l.AlertController.open(h.ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,"info")},this.deleteConnection=a=>{this.remoteFeatures.multiWallet?(u.StorageUtil.deleteAddressFromConnection(a),c.ConnectionController.syncStorageConnections()):l.AlertController.open(h.ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,"info")},this.setConnectedWalletInfo=(a,c)=>{let d=G.ProviderController.getProviderId(c),e=a?{...a,type:d}:void 0;b.ChainController.setAccountProp("connectedWalletInfo",e,c)},this.getIsConnectedState=()=>!!b.ChainController.state.activeCaipAddress,this.addAddressLabel=(a,c,d)=>{let e=b.ChainController.getAccountData(d)?.addressLabels||{};b.ChainController.setAccountProp("addressLabels",{...e,[a]:c},d)},this.removeAddressLabel=(a,c)=>{let d=b.ChainController.getAccountData(c)?.addressLabels||{};b.ChainController.setAccountProp("addressLabels",{...d,[a]:void 0},c)},this.getAddress=a=>{let c=a||b.ChainController.state.activeChain;return b.ChainController.getAccountData(c)?.address},this.resetNetwork=a=>{b.ChainController.resetNetwork(a)},this.addConnector=a=>{d.ConnectorController.addConnector(a)},this.resetWcConnection=()=>{c.ConnectionController.resetWcConnection()},this.setAddressExplorerUrl=(a,c)=>{b.ChainController.setAccountProp("addressExplorerUrl",a,c)},this.setSmartAccountDeployed=(a,c)=>{b.ChainController.setAccountProp("smartAccountDeployed",a,c)},this.setPreferredAccountType=(a,c)=>{b.ChainController.setAccountProp("preferredAccountType",a,c)},this.setEIP6963Enabled=a=>{f.OptionsController.setEIP6963Enabled(a)},this.handleUnsafeRPCRequest=()=>{this.isOpen()?this.isTransactionStackEmpty()||this.redirect("ApproveTransaction"):this.open({view:"ApproveTransaction"})},this.options=a,this.version=a.sdkVersion,this.caipNetworks=this.extendCaipNetworks(a),this.chainNamespaces=this.getChainNamespacesSet(a.adapters,this.caipNetworks),this.defaultCaipNetwork=this.extendDefaultCaipNetwork(a),this.chainAdapters=this.createAdapters(a.adapters),this.readyPromise=this.initialize(a)}getChainNamespacesSet(a,b){let c=a?.map(a=>a.namespace).filter(a=>!!a);return c?.length?[...new Set(c)]:[...new Set(b?.map(a=>a.chainNamespace))]}async initialize(b){if(this.initializeProjectSettings(b),this.initControllers(b),await this.initChainAdapters(),this.sendInitializeEvent(b),f.OptionsController.state.enableReconnect?(await this.syncExistingConnection(),await this.syncAdapterConnections()):await this.unSyncExistingConnection(),this.remoteFeatures=await ak.fetchRemoteFeatures(b),await m.ApiController.fetchUsage(),f.OptionsController.setRemoteFeatures(this.remoteFeatures),this.remoteFeatures.onramp&&F.setOnrampProviders(this.remoteFeatures.onramp),(f.OptionsController.state.remoteFeatures?.email||Array.isArray(f.OptionsController.state.remoteFeatures?.socials)&&f.OptionsController.state.remoteFeatures?.socials.length>0)&&await this.checkAllowedOrigins(),f.OptionsController.state.features?.reownAuthentication||f.OptionsController.state.remoteFeatures?.reownAuthentication){let{ReownAuthentication:b}=await a.A(202490),c=f.OptionsController.state.siwx;c instanceof b||(c&&console.warn("ReownAuthentication option is enabled, SIWX configuration will be overridden."),f.OptionsController.setSIWX(new b))}}async openSend(a){let c=a.namespace||b.ChainController.state.activeChain,d=this.getCaipAddress(c),e=this.getCaipNetwork(c)?.id;if(!d)throw Error("openSend: caipAddress not found");if(e?.toString()!==a.chainId.toString()){let d=b.ChainController.getCaipNetworkById(a.chainId,c);if(!d)throw Error(`openSend: caipNetwork with chainId ${a.chainId} not found`);await this.switchNetwork(d,{throwOnFailure:!0})}try{let b=$.getTokenSymbolByAddress(a.assetAddress);b&&await m.ApiController.fetchTokenImages([b])}catch{}return await A.ModalController.open({view:"WalletSend",data:{send:a}}),new Promise((a,b)=>{let c=J.SendController.subscribeKey("hash",b=>{b&&(e(),a({hash:b}))}),d=A.ModalController.subscribe(a=>{a.open||(e(),b(Error("Modal closed")))}),e=this.createCleanupHandler([c,d])})}toModalOptions(){return{isSwap:function(a){return a?.view==="Swap"},isSend:function(a){return a?.view==="WalletSend"}}}async checkAllowedOrigins(){try{let a=await m.ApiController.fetchAllowedOrigins();if(!e.CoreHelperUtil.isClient())return;let b=window.location.origin;N.isOriginAllowed(b,a,h.ConstantsUtil.DEFAULT_ALLOWED_ANCESTORS)||l.AlertController.open(U.ORIGIN_NOT_ALLOWED,"error")}catch(a){if(!(a instanceof Error))return;switch(a.message){case"RATE_LIMITED":l.AlertController.open(U.RATE_LIMITED_APP_CONFIGURATION,"error");break;case"SERVER_ERROR":{let b=a.cause instanceof Error?a.cause:a;l.AlertController.open({displayMessage:U.SERVER_ERROR_APP_CONFIGURATION.displayMessage,debugMessage:U.SERVER_ERROR_APP_CONFIGURATION.debugMessage(b.message)},"error")}}}}createCleanupHandler(a){return()=>{a.forEach(a=>{try{a()}catch{}})}}sendInitializeEvent(a){let{...b}=a;delete b.adapters,delete b.universalProvider,z.EventsController.sendEvent({type:"track",event:"INITIALIZE",properties:{...b,networks:a.networks.map(a=>a.id),siweConfig:{options:a.siweConfig?.options||{}}}})}initControllers(a){this.initializeOptionsController(a),this.initializeChainController(a),this.initializeThemeController(a),this.initializeConnectionController(a),this.initializeConnectorController()}initAdapterController(){k.AdapterController.initialize(this.chainAdapters)}initializeThemeController(a){a.themeMode&&L.ThemeController.setThemeMode(a.themeMode),a.themeVariables&&L.ThemeController.setThemeVariables(a.themeVariables)}initializeChainController(a){if(!this.connectionControllerClient)throw Error("ConnectionControllerClient must be set");b.ChainController.initialize(a.adapters??[],this.caipNetworks,{connectionControllerClient:this.connectionControllerClient});let c=this.getDefaultNetwork();c&&b.ChainController.setActiveCaipNetwork(c)}initializeConnectionController(a){c.ConnectionController.initialize(a.adapters??[]),c.ConnectionController.setWcBasic(a.basic??!1)}initializeConnectorController(){d.ConnectorController.initialize(this.chainNamespaces)}initializeProjectSettings(a){f.OptionsController.setProjectId(a.projectId),f.OptionsController.setSdkVersion(a.sdkVersion)}initializeOptionsController(a){f.OptionsController.setDebug(!1!==a.debug),f.OptionsController.setEnableWalletGuide(!1!==a.enableWalletGuide),f.OptionsController.setEnableWallets(!1!==a.enableWallets),f.OptionsController.setEIP6963Enabled(!1!==a.enableEIP6963),f.OptionsController.setEnableNetworkSwitch(!1!==a.enableNetworkSwitch),f.OptionsController.setEnableReconnect(!1!==a.enableReconnect),f.OptionsController.setEnableMobileFullScreen(!0===a.enableMobileFullScreen),f.OptionsController.setCoinbasePreference(a.coinbasePreference),f.OptionsController.setEnableAuthLogger(!1!==a.enableAuthLogger),f.OptionsController.setCustomRpcUrls(a.customRpcUrls),f.OptionsController.setEnableEmbedded(a.enableEmbedded),f.OptionsController.setAllWallets(a.allWallets),f.OptionsController.setIncludeWalletIds(a.includeWalletIds),f.OptionsController.setExcludeWalletIds(a.excludeWalletIds),f.OptionsController.setFeaturedWalletIds(a.featuredWalletIds),f.OptionsController.setTokens(a.tokens),f.OptionsController.setTermsConditionsUrl(a.termsConditionsUrl),f.OptionsController.setPrivacyPolicyUrl(a.privacyPolicyUrl),f.OptionsController.setCustomWallets(a.customWallets),f.OptionsController.setFeatures(a.features),f.OptionsController.setAllowUnsupportedChain(a.allowUnsupportedChain),f.OptionsController.setUniversalProviderConfigOverride(a.universalProviderConfigOverride),f.OptionsController.setPreferUniversalLinks(a.experimental_preferUniversalLinks),f.OptionsController.setDefaultAccountTypes(a.defaultAccountTypes);let b=this.getDefaultMetaData();if(!a.metadata&&b&&(a.metadata=b),f.OptionsController.setMetadata(a.metadata),f.OptionsController.setDisableAppend(a.disableAppend),f.OptionsController.setEnableEmbedded(a.enableEmbedded),f.OptionsController.setSIWX(a.siwx),this.features=f.OptionsController.state.features??{},!a.projectId)return void l.AlertController.open(U.PROJECT_ID_NOT_CONFIGURED,"error");if(a.adapters?.find(a=>a.namespace===h.ConstantsUtil.CHAIN.EVM)&&a.siweConfig){if(a.siwx)throw Error("Cannot set both `siweConfig` and `siwx` options");f.OptionsController.setSIWX(a.siweConfig.mapToSIWX())}}getDefaultMetaData(){return e.CoreHelperUtil.isClient()?{name:document.getElementsByTagName("title")?.[0]?.textContent||"",description:document.querySelector('meta[property="og:description"]')?.content||"",url:window.location.origin,icons:[document.querySelector('link[rel~="icon"]')?.href||""]}:null}setUnsupportedNetwork(a){let c=this.getActiveChainNamespace();if(c){let d=R.CaipNetworksUtil.getUnsupportedNetwork(`${c}:${a}`);b.ChainController.setActiveCaipNetwork(d)}}getDefaultNetwork(){return R.CaipNetworksUtil.getCaipNetworkFromStorage(this.defaultCaipNetwork)}extendCaipNetwork(a,b){return R.CaipNetworksUtil.extendCaipNetwork(a,{customNetworkImageUrls:b.chainImages,projectId:b.projectId})}extendCaipNetworks(a){return R.CaipNetworksUtil.extendCaipNetworks(a.networks,{customNetworkImageUrls:a.chainImages,customRpcUrls:a.customRpcUrls,projectId:a.projectId})}extendDefaultCaipNetwork(a){let b=a.networks.find(b=>b.id===a.defaultNetwork?.id);return b?R.CaipNetworksUtil.extendCaipNetwork(b,{customNetworkImageUrls:a.chainImages,customRpcUrls:a.customRpcUrls,projectId:a.projectId}):void 0}async disconnectConnector(a,c){try{this.setLoading(!0,a);let d={connections:[]},e=this.getAdapter(a);return(b.ChainController.state.chains.get(a)?.accountState?.caipAddress||!f.OptionsController.state.enableReconnect)&&e?.disconnect&&(d=await e.disconnect({id:c})),this.setLoading(!1,a),d}catch(b){throw this.setLoading(!1,a),Error(`Failed to disconnect chains: ${b.message}`)}}createClients(){this.connectionControllerClient={connectWalletConnect:async()=>{let a=b.ChainController.state.activeChain,d=this.getAdapter(a),e=this.getCaipNetwork(a)?.id,f=c.ConnectionController.getConnections(a),g=this.remoteFeatures.multiWallet,h=f.length>0;if(!d)throw Error("Adapter not found");let i=await d.connectWalletConnect(e);h&&g||this.close(),this.setClientId(i?.clientId||null),u.StorageUtil.setConnectedNamespaces([...b.ChainController.state.chains.keys()]),await this.syncWalletConnectAccount(),await I.SIWXUtil.initializeIfEnabled()},connectExternal:async a=>{let b=await this.onConnectExternal(a);return await this.connectInactiveNamespaces(a,b),b?{address:b.address}:void 0},reconnectExternal:async({id:a,info:c,type:d,provider:e})=>{let f=b.ChainController.state.activeChain,g=this.getAdapter(f);if(!f)throw Error("reconnectExternal: namespace not found");if(!g)throw Error("reconnectExternal: adapter not found");g?.reconnect&&(await g?.reconnect({id:a,info:c,type:d,provider:e,chainId:this.getCaipNetwork()?.id}),u.StorageUtil.addConnectedNamespace(f),this.syncConnectedWalletInfo(f))},disconnectConnector:async a=>{await this.disconnectConnector(a.namespace,a.id)},disconnect:async a=>{let{id:e,chainNamespace:f,initialDisconnect:g}=a||{},i=f||b.ChainController.state.activeChain,j=d.ConnectorController.getConnectorId(i),k=e===h.ConstantsUtil.CONNECTOR_ID.AUTH||j===h.ConstantsUtil.CONNECTOR_ID.AUTH,l=e===h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT||j===h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;try{let a=Array.from(b.ChainController.state.chains.keys()),h=f?[f]:a;(l||k)&&(h=a);let i=h.map(async a=>{let b=d.ConnectorController.getConnectorId(a),c=await this.disconnectConnector(a,e||b);c&&(k&&u.StorageUtil.deleteConnectedSocialProvider(),c.connections.forEach(b=>{u.StorageUtil.addDisconnectedConnectorId(b.connectorId,a)})),g&&this.onDisconnectNamespace({chainNamespace:a,closeModal:!1})}),j=await Promise.allSettled(i);J.SendController.resetSend(),c.ConnectionController.resetWcConnection(),I.SIWXUtil.getSIWX()?.signOutOnDisconnect&&await I.SIWXUtil.clearSessions(),d.ConnectorController.setFilterByNamespace(void 0),c.ConnectionController.syncStorageConnections();let m=j.filter(a=>"rejected"===a.status);if(m.length>0)throw Error(m.map(a=>a.reason.message).join(", "));z.EventsController.sendEvent({type:"track",event:"DISCONNECT_SUCCESS",properties:{namespace:f||"all"}})}catch(a){throw Error(`Failed to disconnect chains: ${a.message}`)}},checkInstalled:a=>a?a.some(a=>!!window.ethereum?.[String(a)]):!!window.ethereum,signMessage:async a=>{let c=b.ChainController.state.activeChain,d=this.getAdapter(b.ChainController.state.activeChain);if(!c)throw Error("signMessage: namespace not found");if(!d)throw Error("signMessage: adapter not found");let e=this.getAddress(c);if(!e)throw Error("signMessage: address not found");let f=await d?.signMessage({message:a,address:e,provider:G.ProviderController.getProvider(c)});return f?.signature||""},sendTransaction:async a=>{let b=a.chainNamespace;if(!b)throw Error("sendTransaction: namespace not found");if(q.ConstantsUtil.SEND_SUPPORTED_NAMESPACES.includes(b)){let c=this.getAdapter(b);if(!c)throw Error("sendTransaction: adapter not found");let d=G.ProviderController.getProvider(b),e=await c?.sendTransaction({...a,caipNetwork:this.getCaipNetwork(),provider:d});return e?.hash||""}return""},estimateGas:async a=>{let b=a.chainNamespace;if(b===h.ConstantsUtil.CHAIN.EVM){let c=this.getAdapter(b);if(!c)throw Error("estimateGas: adapter is required but got undefined");let d=G.ProviderController.getProvider(b),e=this.getCaipNetwork();if(!e)throw Error("estimateGas: caipNetwork is required but got undefined");let f=await c?.estimateGas({...a,provider:d,caipNetwork:e});return f?.gas||0n}return 0n},getEnsAvatar:async()=>{let a=b.ChainController.state.activeChain;if(!a)throw Error("getEnsAvatar: namespace is required but got undefined");let c=this.getAddress(a);if(!c)throw Error("getEnsAvatar: address not found");await this.syncIdentity({address:c,chainId:Number(this.getCaipNetwork()?.id),chainNamespace:a});let d=b.ChainController.getAccountData();return d?.profileImage||!1},getEnsAddress:async a=>await N.resolveReownName(a),writeContract:async a=>{let c=b.ChainController.state.activeChain,d=this.getAdapter(c);if(!c)throw Error("writeContract: namespace is required but got undefined");if(!d)throw Error("writeContract: adapter is required but got undefined");let e=this.getCaipNetwork(),f=this.getCaipAddress(),g=G.ProviderController.getProvider(c);if(!e||!f)throw Error("writeContract: caipNetwork or caipAddress is required but got undefined");let h=await d?.writeContract({...a,caipNetwork:e,provider:g,caipAddress:f});return h?.hash},parseUnits:(a,c)=>{let d=this.getAdapter(b.ChainController.state.activeChain);if(!d)throw Error("parseUnits: adapter is required but got undefined");return d?.parseUnits({value:a,decimals:c})??0n},formatUnits:(a,c)=>{let d=this.getAdapter(b.ChainController.state.activeChain);if(!d)throw Error("formatUnits: adapter is required but got undefined");return d?.formatUnits({value:a,decimals:c})??"0"},getCapabilities:async a=>{let c=this.getAdapter(b.ChainController.state.activeChain);if(!c)throw Error("getCapabilities: adapter is required but got undefined");return await c?.getCapabilities(a)},grantPermissions:async a=>{let c=this.getAdapter(b.ChainController.state.activeChain);if(!c)throw Error("grantPermissions: adapter is required but got undefined");return await c?.grantPermissions(a)},revokePermissions:async a=>{let c=this.getAdapter(b.ChainController.state.activeChain);if(!c)throw Error("revokePermissions: adapter is required but got undefined");return c?.revokePermissions?await c.revokePermissions(a):"0x"},walletGetAssets:async a=>{let c=this.getAdapter(b.ChainController.state.activeChain);if(!c)throw Error("walletGetAssets: adapter is required but got undefined");return await c?.walletGetAssets(a)??{}},updateBalance:a=>{let b=this.getAddress(a),c=this.getCaipNetwork(a);c&&b&&this.updateNativeBalance(b,c?.id,a)}},c.ConnectionController.setClient(this.connectionControllerClient)}async onConnectExternal(a){let c=b.ChainController.state.activeChain,e=a.chain||c,f=this.getAdapter(e),g=!0;if(a.type===_.ConstantsUtil.CONNECTOR_TYPE_AUTH&&h.ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.some(a=>d.ConnectorController.getConnectorId(a)===h.ConstantsUtil.CONNECTOR_ID.AUTH)&&a.chain!==c&&(g=!1),a.chain&&a.chain!==c&&!a.caipNetwork){let b=this.getCaipNetworks().find(b=>b.chainNamespace===a.chain);b&&g&&this.setCaipNetwork(b)}if(!e)throw Error("connectExternal: namespace not found");if(!f)throw Error("connectExternal: adapter not found");let i=this.getCaipNetwork(e),j=a.caipNetwork||i,k=await f.connect({id:a.id,address:a.address,info:a.info,type:a.type,provider:a.provider,socialUri:a.socialUri,chainId:a.caipNetwork?.id||i?.id,rpcUrl:a.caipNetwork?.rpcUrls?.default?.http?.[0]||i?.rpcUrls?.default?.http?.[0]});if(k)return u.StorageUtil.addConnectedNamespace(e),this.syncProvider({...k,chainNamespace:e}),this.setStatus("connected",e),this.syncConnectedWalletInfo(e),u.StorageUtil.removeDisconnectedConnectorId(a.id,e),{address:k.address,connectedCaipNetwork:j}}async connectInactiveNamespaces(a,c){let d=a.type===_.ConstantsUtil.CONNECTOR_TYPE_AUTH,e=X.HelpersUtil.getOtherAuthNamespaces(c?.connectedCaipNetwork?.chainNamespace),f=b.ChainController.state.activeCaipNetwork,g=this.getAdapter(f?.chainNamespace);d&&(await Promise.all(e.map(async b=>{try{let c=G.ProviderController.getProvider(b),d=this.getCaipNetwork(b),e=this.getAdapter(b);await e?.connect({...a,provider:c,socialUri:void 0,chainId:d?.id,rpcUrl:d?.rpcUrls?.default?.http?.[0]})&&(u.StorageUtil.addConnectedNamespace(b),u.StorageUtil.removeDisconnectedConnectorId(a.id,b),this.setStatus("connected",b),this.syncConnectedWalletInfo(b))}catch(a){l.AlertController.warn(W.displayMessage,W.debugMessage(b,a instanceof Error?a.message:void 0),W.code)}})),f&&await g?.switchNetwork({caipNetwork:f}))}getApprovedCaipNetworksData(){if(G.ProviderController.getProviderId(b.ChainController.state.activeChain)===_.ConstantsUtil.CONNECTOR_TYPE_WALLET_CONNECT){let a=this.universalProvider?.session?.namespaces;return{supportsAllNetworks:this.universalProvider?.session?.peer?.metadata.name==="MetaMask Wallet",approvedCaipNetworkIds:this.getChainsFromNamespaces(a)}}return{supportsAllNetworks:!0,approvedCaipNetworkIds:[]}}async switchCaipNetwork(a){let c=a.chainNamespace;if(this.getAddressByChainNamespace(a.chainNamespace)){let d=G.ProviderController.getProviderId(c);if(a.chainNamespace===b.ChainController.state.activeChain){let b=this.getAdapter(c);await b?.switchNetwork({caipNetwork:a})}else if(this.setCaipNetwork(a),d===_.ConstantsUtil.CONNECTOR_TYPE_WALLET_CONNECT)this.syncWalletConnectAccount();else{let b=this.getAddressByChainNamespace(c);b&&this.syncAccount({address:b,chainId:a.id,chainNamespace:c})}}else this.setCaipNetwork(a)}getChainsFromNamespaces(a={}){return Object.values(a).flatMap(a=>Array.from(new Set([...a.chains||[],...a.accounts.map(a=>{let{chainId:b,chainNamespace:c}=j.ParseUtil.parseCaipAddress(a);return`${c}:${b}`})])))}createAdapters(a){return this.createClients(),this.chainNamespaces.reduce((b,c)=>{let d=a?.find(a=>a.namespace===c);return d?(d.construct({namespace:c,projectId:this.options?.projectId,networks:this.caipNetworks?.filter(({chainNamespace:a})=>a===c)}),b[c]=d):b[c]=new ah({namespace:c,networks:this.getCaipNetworks()}),b},{})}async initChainAdapter(a){this.onConnectors(a),this.listenAdapter(a);let b=this.getAdapter(a);if(!b)throw Error("adapter not found");await b.syncConnectors(),await this.createUniversalProviderForAdapter(a)}async initChainAdapters(){await Promise.all(this.chainNamespaces.map(async a=>{await this.initChainAdapter(a)})),this.initAdapterController()}onConnectors(a){let b=this.getAdapter(a);b?.on("connectors",this.setConnectors.bind(this))}listenAdapter(a){let d=this.getAdapter(a);if(!d)return;let e=u.StorageUtil.getConnectionStatus();!1===f.OptionsController.state.enableReconnect?this.setStatus("disconnected",a):"connected"===e?this.setStatus("connecting",a):("disconnected"===e&&u.StorageUtil.clearAddressCache(),this.setStatus(e,a)),d.on("switchNetwork",({address:c,chainId:d})=>{let e=this.getCaipNetworks().find(a=>a.id.toString()===d.toString()||a.caipNetworkId.toString()===d.toString()),f=b.ChainController.state.activeChain===a,g=b.ChainController.state.chains.get(a)?.accountState?.address;if(e){let b=f&&c?c:g;b&&this.syncAccount({address:b,chainId:e.id,chainNamespace:a})}else this.setUnsupportedNetwork(d)}),d.on("disconnect",()=>{let b=this.remoteFeatures.multiWallet,d=Array.from(c.ConnectionController.state.connections.values()).flat();this.onDisconnectNamespace({chainNamespace:a,closeModal:!b||0===d.length})}),d.on("connections",b=>{this.setConnections(b,a)}),d.on("pendingTransactions",()=>{let c=this.getAddress(a),d=b.ChainController.state.activeCaipNetwork;c&&d?.id&&this.updateNativeBalance(c,d.id,d.chainNamespace)}),d.on("accountChanged",({address:c,chainId:d,connector:e})=>{this.handlePreviousConnectorConnection(e);let f=b.ChainController.state.activeChain===a;e?.provider&&(this.syncProvider({id:e.id,type:e.type,provider:e?.provider,chainNamespace:a}),this.syncConnectedWalletInfo(a));let g=b.ChainController.getNetworkData(a)?.caipNetwork?.id,h=d||g;f&&h?this.syncAccount({address:c,chainId:h,chainNamespace:a}):!f&&h?(this.syncAccountInfo(c,h,a),this.syncBalance({address:c,chainId:h,chainNamespace:a})):this.syncAccountInfo(c,d,a),u.StorageUtil.addConnectedNamespace(a)})}async handlePreviousConnectorConnection(a){let b=a?.chain,e=a?.id,g=d.ConnectorController.getConnectorId(b),h=f.OptionsController.state.remoteFeatures?.multiWallet,i=g!==e,j=b&&e&&g&&i&&!h;try{j&&await c.ConnectionController.disconnect({id:g,namespace:b})}catch(a){console.warn("Error disconnecting previous connector",a)}}async createUniversalProviderForAdapter(a){await this.getUniversalProvider(),this.universalProvider&&await this.chainAdapters?.[a]?.setUniversalProvider?.(this.universalProvider)}async syncExistingConnection(){await Promise.allSettled(this.chainNamespaces.map(a=>this.syncNamespaceConnection(a)))}async unSyncExistingConnection(){try{await Promise.allSettled(this.chainNamespaces.map(a=>c.ConnectionController.disconnect({namespace:a,initialDisconnect:!0})))}catch(a){console.error("Error disconnecting existing connections:",a)}}async reconnectWalletConnect(){await this.syncWalletConnectAccount();let a=this.getAddress();this.getCaipAddress()||u.StorageUtil.deleteRecentWallet();let b=u.StorageUtil.getRecentWallet();z.EventsController.sendEvent({type:"track",event:"CONNECT_SUCCESS",address:a,properties:{method:e.CoreHelperUtil.isMobile()?"mobile":"qrcode",name:b?.name||"Unknown",reconnect:!0,view:w.RouterController.state.view,walletRank:b?.order}})}async syncNamespaceConnection(a){try{a===h.ConstantsUtil.CHAIN.EVM&&e.CoreHelperUtil.isSafeApp()&&d.ConnectorController.setConnectorId(h.ConstantsUtil.CONNECTOR_ID.SAFE,a);let b=d.ConnectorController.getConnectorId(a);switch(this.setStatus("connecting",a),b){case h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT:await this.reconnectWalletConnect();break;case h.ConstantsUtil.CONNECTOR_ID.AUTH:break;default:await this.syncAdapterConnection(a)}}catch(b){console.warn("AppKit couldn't sync existing connection",b),this.setStatus("disconnected",a)}}onDisconnectNamespace(a){let{chainNamespace:c,closeModal:e}=a||{};b.ChainController.resetAccount(c),b.ChainController.resetNetwork(c),u.StorageUtil.removeConnectedNamespace(c);let f=Array.from(b.ChainController.state.chains.keys());(c?[c]:f).forEach(a=>u.StorageUtil.addDisconnectedConnectorId(d.ConnectorController.getConnectorId(a)||"",a)),d.ConnectorController.removeConnectorId(c),G.ProviderController.resetChain(c),this.setUser(null,c),this.setStatus("disconnected",c),this.setConnectedWalletInfo(null,c),!1!==e&&A.ModalController.close()}async syncAdapterConnections(){await Promise.allSettled(this.chainNamespaces.map(a=>{let b=this.getAdapter(a),c=this.getCaipAddress(a),d=this.getCaipNetwork(a);return b?.syncConnections({connectToFirstConnector:!c,caipNetwork:d})}))}async syncAdapterConnection(a){let b=this.getAdapter(a),c=this.getCaipNetwork(a),e=d.ConnectorController.getConnectorId(a),f=d.ConnectorController.getConnectors(a).find(a=>a.id===e);try{if(!b||!f)throw Error(`Adapter or connector not found for namespace ${a}`);if(!c?.id)throw Error("CaipNetwork not found");let d=await b?.syncConnection({namespace:a,id:f.id,chainId:c.id,rpcUrl:c?.rpcUrls?.default?.http?.[0]});d?(this.syncProvider({...d,chainNamespace:a}),await this.syncAccount({...d,chainNamespace:a}),this.setStatus("connected",a),z.EventsController.sendEvent({type:"track",event:"CONNECT_SUCCESS",address:d.address,properties:{method:"browser",name:f.info?.name||f.name||"Unknown",reconnect:!0,view:w.RouterController.state.view,walletRank:void 0}})):this.setStatus("disconnected",a)}catch(b){this.onDisconnectNamespace({chainNamespace:a,closeModal:!1})}}async syncWalletConnectAccount(){let a=Object.keys(this.universalProvider?.session?.namespaces||{}),c=this.chainNamespaces.map(async c=>{let e=this.getAdapter(c);if(!e)return;let f=this.universalProvider?.session?.namespaces?.[c]?.accounts||[],g=b.ChainController.state.activeCaipNetwork?.id,i=f.find(a=>{let{chainId:b}=j.ParseUtil.parseCaipAddress(a);return b===g?.toString()})||f[0];if(i){let a=j.ParseUtil.validateCaipAddress(i),{chainId:f,address:g}=j.ParseUtil.parseCaipAddress(a);if(G.ProviderController.setProviderId(c,_.ConstantsUtil.CONNECTOR_TYPE_WALLET_CONNECT),this.caipNetworks&&b.ChainController.state.activeCaipNetwork&&e.namespace!==h.ConstantsUtil.CHAIN.EVM){let a=e.getWalletConnectProvider({caipNetworks:this.getCaipNetworks(),provider:this.universalProvider,activeCaipNetwork:b.ChainController.state.activeCaipNetwork});G.ProviderController.setProvider(c,a)}else G.ProviderController.setProvider(c,this.universalProvider);d.ConnectorController.setConnectorId(h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT,c),u.StorageUtil.addConnectedNamespace(c),await this.syncAccount({address:g,chainId:f,chainNamespace:c})}else a.includes(c)&&this.setStatus("disconnected",c);let k=this.getApprovedCaipNetworksData();this.syncConnectedWalletInfo(c),b.ChainController.setApprovedCaipNetworksData(c,{approvedCaipNetworkIds:k.approvedCaipNetworkIds,supportsAllNetworks:k.supportsAllNetworks})});await Promise.all(c)}syncProvider({type:a,provider:b,id:c,chainNamespace:e}){G.ProviderController.setProviderId(e,a),G.ProviderController.setProvider(e,b),d.ConnectorController.setConnectorId(c,e)}async syncAccount(a){let c=a.chainNamespace===b.ChainController.state.activeChain,d=b.ChainController.getCaipNetworkByNamespace(a.chainNamespace,a.chainId),{address:e,chainId:g,chainNamespace:i}=a,{chainId:k}=u.StorageUtil.getActiveNetworkProps(),l=d?.id||k,m=b.ChainController.state.activeCaipNetwork?.name===h.ConstantsUtil.UNSUPPORTED_NETWORK_NAME,n=b.ChainController.getNetworkProp("supportsAllNetworks",i);if(this.setStatus("connected",i),(!m||n)&&l){let a=this.getCaipNetworks().find(a=>a.id.toString()===l.toString()),k=this.getCaipNetworks().find(a=>a.chainNamespace===i);if(!n&&!a&&!k){let b=this.getApprovedCaipNetworkIds()||[],c=b.find(a=>j.ParseUtil.parseCaipNetworkId(a)?.chainId===l.toString()),d=b.find(a=>j.ParseUtil.parseCaipNetworkId(a)?.chainNamespace===i);a=this.getCaipNetworks().find(a=>a.caipNetworkId===c),k=this.getCaipNetworks().find(a=>a.caipNetworkId===d||"deprecatedCaipNetworkId"in a&&a.deprecatedCaipNetworkId===d)}let m=a||k;m?.chainNamespace===b.ChainController.state.activeChain?f.OptionsController.state.enableNetworkSwitch&&!f.OptionsController.state.allowUnsupportedChain&&b.ChainController.state.activeCaipNetwork?.name===h.ConstantsUtil.UNSUPPORTED_NETWORK_NAME?b.ChainController.showUnsupportedChainUI():this.setCaipNetwork(m):!c&&d&&this.setCaipNetworkOfNamespace(d,i),this.syncConnectedWalletInfo(i);let o=this.getAddress(i);X.HelpersUtil.isLowerCaseMatch(e,o)||this.syncAccountInfo(e,m?.id,i),c?await this.syncBalance({address:e,chainId:m?.id,chainNamespace:i}):await this.syncBalance({address:e,chainId:d?.id,chainNamespace:i}),this.syncIdentity({address:e,chainId:g,chainNamespace:i})}}async syncAccountInfo(a,b,c){let d=this.getCaipAddress(c),e=b||d?.split(":")[1];if(!e)return;let f=`${c}:${e}:${a}`;this.setCaipAddress(f,c,!0),await this.syncIdentity({address:a,chainId:e,chainNamespace:c})}async syncReownName(a,b){try{let c=await this.getReownName(a);if(c[0]){let a=c[0];this.setProfileName(a.name,b)}else this.setProfileName(null,b)}catch{this.setProfileName(null,b)}}syncConnectedWalletInfo(a){let b=d.ConnectorController.getConnectorId(a),c=G.ProviderController.getProviderId(a);if(c===_.ConstantsUtil.CONNECTOR_TYPE_ANNOUNCED||c===_.ConstantsUtil.CONNECTOR_TYPE_INJECTED){if(b){let c=this.getConnectors().find(a=>{let c=a.id===b,d=a.info?.rdns===b,e=a.connectors?.some(a=>a.id===b||a.info?.rdns===b);return c||d||!!e});if(c){let{info:b,name:d,imageUrl:e}=c,f=e||this.getConnectorImage(c);this.setConnectedWalletInfo({name:d,icon:f,...b},a)}}}else if(c===_.ConstantsUtil.CONNECTOR_TYPE_WALLET_CONNECT){let b=G.ProviderController.getProvider(a);b?.session&&this.setConnectedWalletInfo({...b.session.peer.metadata,name:b.session.peer.metadata.name,icon:b.session.peer.metadata.icons?.[0]},a)}else if(b&&(b===h.ConstantsUtil.CONNECTOR_ID.COINBASE_SDK||b===h.ConstantsUtil.CONNECTOR_ID.COINBASE)){let c=this.getConnectors().find(a=>a.id===b),d=c?.name||"Coinbase Wallet",e=c?.imageUrl||this.getConnectorImage(c),f=c?.info;this.setConnectedWalletInfo({...f,name:d,icon:e},a)}}async syncBalance(a){i.NetworkUtil.getNetworksByNamespace(this.getCaipNetworks(),a.chainNamespace).find(b=>b.id.toString()===a.chainId?.toString())&&a.chainId&&await this.updateNativeBalance(a.address,a.chainId,a.chainNamespace)}async ready(){await this.readyPromise}async updateNativeBalance(a,c,d){let e=this.getAdapter(d),f=b.ChainController.getCaipNetworkByNamespace(d,c);if(e){let b=await e.getBalance({address:a,chainId:c,caipNetwork:f,tokens:this.options.tokens});return this.setBalance(b.balance,b.symbol,d),b}}async initializeUniversalAdapter(){let a=Z.createLogger((a,...b)=>{a&&this.handleAlertError(a),console.error(...b)}),b={projectId:this.options?.projectId,metadata:{name:this.options?.metadata?this.options?.metadata.name:"",description:this.options?.metadata?this.options?.metadata.description:"",url:this.options?.metadata?this.options?.metadata.url:"",icons:this.options?.metadata?this.options?.metadata.icons:[""]},logger:a};f.OptionsController.setManualWCControl(!!this.options?.manualWCControl),this.universalProvider=this.options.universalProvider??await g.default.init(b),!1===f.OptionsController.state.enableReconnect&&this.universalProvider.session&&await this.universalProvider.disconnect(),this.listenWalletConnect()}listenWalletConnect(){this.universalProvider&&this.chainNamespaces.forEach(a=>{N.listenWcProvider({universalProvider:this.universalProvider,namespace:a,onDisplayUri:a=>{c.ConnectionController.setUri(a)},onConnect:a=>{let{address:b}=e.CoreHelperUtil.getAccount(a[0]);c.ConnectionController.finalizeWcConnection(b)},onDisconnect:()=>{b.ChainController.state.noAdapters&&this.resetAccount(a),c.ConnectionController.resetWcConnection()},onChainChanged:c=>{let e=b.ChainController.state.activeChain,f=e&&d.ConnectorController.state.activeConnectorIds[e]===h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;if(e===a&&(b.ChainController.state.noAdapters||f)){let a=this.getCaipNetworks().find(a=>a.id.toString()===c.toString()||a.caipNetworkId.toString()===c.toString()),b=this.getCaipNetwork();if(!a)return void this.setUnsupportedNetwork(c);b?.id.toString()!==a?.id.toString()&&b?.chainNamespace===a?.chainNamespace&&this.setCaipNetwork(a)}},onAccountsChanged:c=>{let e=b.ChainController.state.activeChain,f=e&&d.ConnectorController.state.activeConnectorIds[e]===h.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;if(e===a&&(b.ChainController.state.noAdapters||f)){let a=c?.[0];a&&this.syncAccount({address:a.address,chainId:a.chainId,chainNamespace:a.chainNamespace})}}})})}createUniversalProvider(){return!this.universalProviderInitPromise&&e.CoreHelperUtil.isClient()&&this.options?.projectId&&(this.universalProviderInitPromise=this.initializeUniversalAdapter()),this.universalProviderInitPromise}async getUniversalProvider(){if(!this.universalProvider)try{await this.createUniversalProvider()}catch(a){z.EventsController.sendEvent({type:"error",event:"INTERNAL_SDK_ERROR",properties:{errorType:"UniversalProviderInitError",errorMessage:a instanceof Error?a.message:"Unknown",uncaught:!1}}),console.error("AppKit:getUniversalProvider - Cannot create provider",a)}return this.universalProvider}getDisabledCaipNetworks(){let a=b.ChainController.getAllApprovedCaipNetworkIds(),c=b.ChainController.getAllRequestedCaipNetworks();return e.CoreHelperUtil.sortRequestedNetworks(a,c).filter(a=>b.ChainController.isCaipNetworkDisabled(a))}handleAlertError(a){let[b,c]=Object.entries(T).find(([,{message:b}])=>a.message.includes(b))??[],{message:d,alertErrorKey:e}=c??{};if(b&&d&&!this.reportedAlertErrors[b]){let a=U[e];a&&(l.AlertController.open(a,"error"),this.reportedAlertErrors[b]=!0)}}getAdapter(a){if(a)return this.chainAdapters?.[a]}createAdapter(a){if(!a)return;let b=a.namespace;b&&(this.createClients(),a.namespace=b,a.construct({namespace:b,projectId:this.options?.projectId,networks:this.caipNetworks?.filter(({chainNamespace:a})=>a===b)}),this.chainNamespaces.includes(b)||this.chainNamespaces.push(b),this.chainAdapters&&(this.chainAdapters[b]=a))}async open(a){await this.injectModalUi(),a?.uri&&c.ConnectionController.setUri(a.uri);let{isSwap:b,isSend:d}=this.toModalOptions();return b(a)?A.ModalController.open({...a,data:{swap:a.arguments}}):d(a)&&a.arguments?this.openSend(a.arguments):A.ModalController.open(a)}async close(){await this.injectModalUi(),A.ModalController.close()}setLoading(a,b){A.ModalController.setLoading(a,b)}async disconnect(a){await c.ConnectionController.disconnect({namespace:a})}getSIWX(){return f.OptionsController.state.siwx}getError(){return""}getChainId(){return b.ChainController.state.activeCaipNetwork?.id}async switchNetwork(a,{throwOnFailure:c=!1}={}){let d=this.getCaipNetworks().find(b=>b.id===a.id);d?await b.ChainController.switchActiveNetwork(d,{throwOnFailure:c}):l.AlertController.open(U.SWITCH_NETWORK_NOT_FOUND,"error")}getWalletProvider(){return b.ChainController.state.activeChain?G.ProviderController.state.providers[b.ChainController.state.activeChain]:null}getWalletProviderType(){return G.ProviderController.getProviderId(b.ChainController.state.activeChain)}subscribeProviders(a){return G.ProviderController.subscribeProviders(a)}getThemeMode(){return L.ThemeController.state.themeMode}getThemeVariables(){return L.ThemeController.state.themeVariables}setThemeMode(a){L.ThemeController.setThemeMode(a),(0,Q.setColorTheme)(L.ThemeController.state.themeMode)}setTermsConditionsUrl(a){f.OptionsController.setTermsConditionsUrl(a)}setPrivacyPolicyUrl(a){f.OptionsController.setPrivacyPolicyUrl(a)}setThemeVariables(a){L.ThemeController.setThemeVariables(a),(0,Q.setThemeVariables)(L.ThemeController.state.themeVariables)}subscribeTheme(a){return L.ThemeController.subscribe(a)}subscribeConnections(a){return this.remoteFeatures.multiWallet?c.ConnectionController.subscribe(a):(l.AlertController.open(h.ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT,"info"),()=>void 0)}getWalletInfo(a){if(a)return b.ChainController.state.chains.get(a)?.accountState?.connectedWalletInfo;let c=b.ChainController.getAccountData();return c?.connectedWalletInfo}getAccount(a){let f=a||b.ChainController.state.activeChain,g=d.ConnectorController.getAuthConnector(f),i=b.ChainController.getAccountData(f),j=u.StorageUtil.getConnectedConnectorId(b.ChainController.state.activeChain),k=c.ConnectionController.getConnections(f);if(!f)throw Error("AppKit:getAccount - namespace is required");let l=k.flatMap(a=>a.accounts.map(({address:a,type:b,publicKey:c})=>e.CoreHelperUtil.createAccount(f,a,b||"eoa",c)));if(i)return{allAccounts:l,caipAddress:i.caipAddress,address:e.CoreHelperUtil.getPlainAddress(i.caipAddress),isConnected:!!i.caipAddress,status:i.status,embeddedWalletInfo:g&&j===h.ConstantsUtil.CONNECTOR_ID.AUTH?{user:i.user?{...i.user,username:u.StorageUtil.getConnectedSocialUsername()}:void 0,authProvider:i.socialProvider||"email",accountType:(0,O.getPreferredAccountType)(f),isSmartAccountDeployed:!!i.smartAccountDeployed}:void 0}}subscribeAccount(a,c){let e=()=>{let b=this.getAccount(c);b&&a(b)};c?b.ChainController.subscribeChainProp("accountState",e,c):b.ChainController.subscribe(e),d.ConnectorController.subscribe(e)}subscribeNetwork(a){return b.ChainController.subscribe(({activeCaipNetwork:b})=>{a({caipNetwork:b,chainId:b?.id,caipNetworkId:b?.caipNetworkId})})}subscribeWalletInfo(a,c){return c?b.ChainController.subscribeChainProp("accountState",b=>a(b?.connectedWalletInfo),c):b.ChainController.subscribeChainProp("accountState",b=>a(b?.connectedWalletInfo))}subscribeShouldUpdateToAddress(a){b.ChainController.subscribeChainProp("accountState",b=>a(b?.shouldUpdateToAddress))}subscribeCaipNetworkChange(a){b.ChainController.subscribeKey("activeCaipNetwork",a)}getState(){return H.PublicStateController.state}getRemoteFeatures(){return f.OptionsController.state.remoteFeatures}subscribeState(a){return H.PublicStateController.subscribe(a)}subscribeRemoteFeatures(a){return f.OptionsController.subscribeKey("remoteFeatures",a)}showErrorMessage(a){K.SnackController.showError(a)}showSuccessMessage(a){K.SnackController.showSuccess(a)}getEvent(){return{...z.EventsController.state}}subscribeEvents(a){return z.EventsController.subscribe(a)}replace(a){w.RouterController.replace(a)}redirect(a){w.RouterController.push(a)}popTransactionStack(a){w.RouterController.popTransactionStack(a)}isOpen(){return A.ModalController.state.open}isTransactionStackEmpty(){return 0===w.RouterController.state.transactionStack.length}static getInstance(){return this.instance}updateFeatures(a){f.OptionsController.setFeatures(a)}updateRemoteFeatures(a){f.OptionsController.setRemoteFeatures(a)}updateOptions(a){let b={...f.OptionsController.state||{},...a};f.OptionsController.setOptions(b)}setConnectMethodsOrder(a){f.OptionsController.setConnectMethodsOrder(a)}setWalletFeaturesOrder(a){f.OptionsController.setWalletFeaturesOrder(a)}setCollapseWallets(a){f.OptionsController.setCollapseWallets(a)}setSocialsOrder(a){f.OptionsController.setSocialsOrder(a)}getConnectMethodsOrder(){return P.WalletUtil.getConnectOrderMethod(f.OptionsController.state.features,d.ConnectorController.getConnectors())}addNetwork(a,c){if(this.chainAdapters&&!this.chainAdapters[a])throw Error(`Adapter for namespace ${a} doesn't exist`);let d=this.extendCaipNetwork(c,this.options);this.getCaipNetworks().find(a=>a.id===d.id)||b.ChainController.addNetwork(d)}removeNetwork(a,c){if(this.chainAdapters&&!this.chainAdapters[a])throw Error(`Adapter for namespace ${a} doesn't exist`);this.getCaipNetworks().find(a=>a.id===c)&&b.ChainController.removeNetwork(a,c)}}let am=!1;class an extends al{async open(a){d.ConnectorController.isConnected()||await super.open(a)}async close(){if(await super.close(),this.options.manualWCControl){let a=b.ChainController.getAccountData(this.activeChainNamespace)?.address;c.ConnectionController.finalizeWcConnection(a)}}async syncIdentity(a){return Promise.resolve()}async syncBalance(a){return Promise.resolve()}async injectModalUi(){if(!am&&e.CoreHelperUtil.isClient()){if(await a.A(754163),await a.A(524103),!document.querySelector("w3m-modal")){let a=document.createElement("w3m-modal");f.OptionsController.state.disableAppend||f.OptionsController.state.enableEmbedded||document.body.insertAdjacentElement("beforeend",a)}am=!0}}}function ao(a){return new an({...a,basic:!0,sdkVersion:"html-core-1.8.11"})}a.s(["createAppKit",()=>ao],611286),a.i(611286),a.s(["AppKit",()=>an,"createAppKit",()=>ao],760912)}];

//# sourceMappingURL=node_modules_%40reown_appkit_dist_esm_exports_core_5ad3ab6d.js.map