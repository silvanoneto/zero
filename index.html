<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="CRIO: onde achar e criar são o mesmo movimento">
    <title>∅ → CRIO</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='80' font-size='80' fill='%23f0f0f0'>∅</text></svg>">
    
    <!-- Marked.js para renderizar markdown -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --void: #0a0a0a;
            --emergence: #f0f0f0;
            --trace: #666;
            --glow: rgba(255, 255, 255, 0.1);
        }

        body.light-theme {
            --void: #f0f0f0;
            --emergence: #0a0a0a;
            --trace: #999;
            --glow: rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: 'Georgia', 'Times New Roman', serif;
            background: var(--void);
            color: var(--emergence);
            line-height: 1.8;
            padding: 2rem;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: crosshair;
            transition: background 0.6s ease, color 0.6s ease;
        }

        /* Tremor animation with variable intensity */
        @keyframes tremor {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(calc(var(--tremor-intensity) * -1.5px), calc(var(--tremor-intensity) * 1px)); }
            20% { transform: translate(calc(var(--tremor-intensity) * 1px), calc(var(--tremor-intensity) * -1.5px)); }
            30% { transform: translate(calc(var(--tremor-intensity) * -1px), calc(var(--tremor-intensity) * -1px)); }
            40% { transform: translate(calc(var(--tremor-intensity) * 1.5px), calc(var(--tremor-intensity) * 1px)); }
            50% { transform: translate(calc(var(--tremor-intensity) * -1.5px), calc(var(--tremor-intensity) * 0.5px)); }
            60% { transform: translate(calc(var(--tremor-intensity) * 1px), calc(var(--tremor-intensity) * 1.5px)); }
            70% { transform: translate(calc(var(--tremor-intensity) * -1px), calc(var(--tremor-intensity) * -1.5px)); }
            80% { transform: translate(calc(var(--tremor-intensity) * 1.5px), calc(var(--tremor-intensity) * -1px)); }
            90% { transform: translate(calc(var(--tremor-intensity) * -1px), calc(var(--tremor-intensity) * 1.5px)); }
        }

        main {
            max-width: 800px;
            margin: 0 auto;
            width: 100%;
            --tremor-intensity: 0;
            animation: tremor 0.1s infinite;
        }

        #content {
            opacity: 0;
            animation: emerge 2s 1s ease-out forwards;
        }

        h1 {
            font-size: clamp(2rem, 8vw, 4rem);
            font-weight: 300;
            letter-spacing: 0.1em;
            margin-bottom: 2rem;
            text-align: center;
        }

        h2 {
            font-size: 1.8rem;
            font-weight: 400;
            margin: 3rem 0 1.5rem 0;
            letter-spacing: 0.05em;
            border-bottom: 1px solid var(--glow);
            padding-bottom: 0.5rem;
        }

        h3 {
            font-size: 1.3rem;
            font-weight: 400;
            margin: 2rem 0 1rem 0;
            color: var(--trace);
            font-style: italic;
        }

        h4, h5, h6 {
            font-weight: 400;
            margin: 1.5rem 0 1rem 0;
            color: var(--emergence);
        }

        p {
            margin-bottom: 1.2rem;
            text-align: justify;
            hyphens: auto;
        }

        /* Primeira linha (citação) */
        #content > blockquote:first-child {
            margin-top: 1rem;
            margin-bottom: 3rem;
            text-align: center;
            font-size: 1.1rem;
        }

        blockquote {
            margin: 2rem 0;
            padding: 1.5rem;
            border-left: 3px solid var(--emergence);
            background: rgba(255, 255, 255, 0.02);
            font-style: italic;
            color: var(--trace);
        }

        blockquote p {
            margin: 0;
            text-align: left;
        }

        strong {
            font-weight: 600;
            color: var(--emergence);
        }

        em {
            font-style: italic;
        }

        ul, ol {
            margin: 1.5rem 0 1.5rem 2rem;
        }

        li {
            margin-bottom: 0.8rem;
        }

        li p {
            margin-bottom: 0.5rem;
        }

        hr {
            border: none;
            border-top: 1px solid var(--glow);
            margin: 4rem 0;
            opacity: 0.5;
        }

        code {
            background: rgba(255, 255, 255, 0.05);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        pre {
            background: rgba(255, 255, 255, 0.03);
            padding: 1rem;
            border-radius: 4px;
            overflow-x: auto;
            margin: 1.5rem 0;
        }

        pre code {
            background: none;
            padding: 0;
        }

        a {
            color: var(--emergence);
            text-decoration: none;
            border-bottom: 1px solid var(--glow);
            transition: border-color 0.3s ease;
        }

        a:hover {
            border-bottom-color: var(--emergence);
        }

        @keyframes emerge {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 1rem;
            }

            p {
                text-align: left;
            }

            h1 {
                font-size: 2rem;
            }

            h2 {
                font-size: 1.5rem;
            }
        }

        /* Audio controls */
        .audio-ui {
            position: fixed;
            right: 1rem;
            bottom: 1rem;
            background: rgba(255,255,255,0.03);
            border: 1px solid var(--glow);
            color: var(--emergence);
            padding: 0.5rem 0.6rem;
            display: flex;
            gap: 0.5rem;
            align-items: center;
            border-radius: 6px;
            backdrop-filter: blur(4px);
            z-index: 1200;
        }

        .audio-ui button {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.04);
            color: var(--emergence);
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 1rem;
            min-width: 2.5rem;
            text-align: center;
        }

        .audio-ui .label {
            font-size: 1rem;
            color: var(--emergence);
            min-width: 2.5rem;
            text-align: center;
        }

        .audio-ui .label.blink {
            animation: blink 1s step-end infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            50.01%, 100% { opacity: 0.3; }
        }

        /* Partículas de fundo com tremulidade aleatória */
        @keyframes float {
            0% { 
                transform: translate(0, 0) rotate(0deg);
                opacity: 0.1;
            }
            25% { 
                transform: translate(var(--tx1), var(--ty1)) rotate(90deg);
                opacity: 0.3;
            }
            50% { 
                transform: translate(var(--tx2), var(--ty2)) rotate(180deg);
                opacity: 0.2;
            }
            75% { 
                transform: translate(var(--tx3), var(--ty3)) rotate(270deg);
                opacity: 0.3;
            }
            100% { 
                transform: translate(0, 0) rotate(360deg);
                opacity: 0.1;
            }
        }

        @keyframes tremor-particle {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(calc(var(--shake-x1) * var(--chaos-intensity, 1)), calc(var(--shake-y1) * var(--chaos-intensity, 1))); }
            20% { transform: translate(calc(var(--shake-x2) * var(--chaos-intensity, 1)), calc(var(--shake-y2) * var(--chaos-intensity, 1))); }
            30% { transform: translate(calc(var(--shake-x3) * var(--chaos-intensity, 1)), calc(var(--shake-y3) * var(--chaos-intensity, 1))); }
            40% { transform: translate(calc(var(--shake-x4) * var(--chaos-intensity, 1)), calc(var(--shake-y4) * var(--chaos-intensity, 1))); }
            50% { transform: translate(calc(var(--shake-x5) * var(--chaos-intensity, 1)), calc(var(--shake-y5) * var(--chaos-intensity, 1))); }
            60% { transform: translate(calc(var(--shake-x6) * var(--chaos-intensity, 1)), calc(var(--shake-y6) * var(--chaos-intensity, 1))); }
            70% { transform: translate(calc(var(--shake-x7) * var(--chaos-intensity, 1)), calc(var(--shake-y7) * var(--chaos-intensity, 1))); }
            80% { transform: translate(calc(var(--shake-x8) * var(--chaos-intensity, 1)), calc(var(--shake-y8) * var(--chaos-intensity, 1))); }
            90% { transform: translate(calc(var(--shake-x9) * var(--chaos-intensity, 1)), calc(var(--shake-y9) * var(--chaos-intensity, 1))); }
        }

        .particle {
            position: fixed;
            width: 2px;
            height: 2px;
            background: var(--emergence);
            border-radius: 50%;
            pointer-events: none;
            z-index: -1;
            transition: opacity 3s ease-out;
            --chaos-intensity: 1;
        }

        .particle.floating {
            animation: 
                float var(--float-duration) infinite ease-in-out,
                tremor-particle var(--tremor-duration) infinite;
        }

        .particle.stabilized {
            animation-play-state: paused !important;
        }

        .loading {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--trace);
            font-style: italic;
        }
    </style>
</head>
<body>
    <main>
        <div id="content" class="loading">
            ∅ → carregando CRIO...
        </div>
    </main>

    <!-- Áudio de fundo -->
    <audio id="bg-audio" src="CRIO.mp3" preload="none"></audio>

    <!-- Controles de áudio minimalistas -->
    <div class="audio-ui" role="region" aria-label="Controles de áudio" style="display: none;">
        <button id="mute-btn" title="Mudo por 99 segundos" aria-label="Mudo por 99 segundos">CRIO</button>
        <div class="label" id="mute-label" style="display: none;">—</div>
    </div>

    <script>
        // Configurar marked para melhor renderização
        marked.setOptions({
            breaks: true,
            gfm: true,
            headerIds: true,
            mangle: false
        });

        // Carregar e renderizar o markdown
        fetch('CRIOS.md')
            .then(response => {
                if (!response.ok) throw new Error('Arquivo não encontrado');
                return response.text();
            })
            .then(markdown => {
                const content = document.getElementById('content');
                content.innerHTML = marked.parse(markdown);
                content.classList.remove('loading');
            })
            .catch(error => {
                console.error('Erro ao carregar CRIOS.md:', error);
                // Fallback: tentar carregar com caminho absoluto ou usar XMLHttpRequest
                const xhr = new XMLHttpRequest();
                xhr.open('GET', 'CRIOS.md', true);
                xhr.onload = function() {
                    if (xhr.status === 200 || xhr.status === 0) { // 0 para file://
                        const content = document.getElementById('content');
                        content.innerHTML = marked.parse(xhr.responseText);
                        content.classList.remove('loading');
                    } else {
                        document.getElementById('content').innerHTML = 
                            '<p style="color: var(--trace); text-align: center;">Erro ao carregar CRIOS.md. Abra este arquivo em um servidor web local.</p>';
                    }
                };
                xhr.onerror = function() {
                    document.getElementById('content').innerHTML = 
                        '<p style="color: var(--trace); text-align: center;">Para visualizar o conteúdo completo, abra em um servidor web local:<br><code>python3 -m http.server 8000</code></p>';
                };
                xhr.send();
            });

        // Adicionar mais partículas dinamicamente com tremulidade aleatória
        function createParticles(count) {
            const body = document.body;
            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle floating';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.left = Math.random() * 100 + '%';
                
                // Variáveis CSS customizadas para movimento aleatório
                const tx1 = (Math.random() - 0.5) * 200;
                const ty1 = (Math.random() - 0.5) * 200;
                const tx2 = (Math.random() - 0.5) * 200;
                const ty2 = (Math.random() - 0.5) * 200;
                const tx3 = (Math.random() - 0.5) * 200;
                const ty3 = (Math.random() - 0.5) * 200;
                
                particle.style.setProperty('--tx1', tx1 + 'px');
                particle.style.setProperty('--ty1', ty1 + 'px');
                particle.style.setProperty('--tx2', tx2 + 'px');
                particle.style.setProperty('--ty2', ty2 + 'px');
                particle.style.setProperty('--tx3', tx3 + 'px');
                particle.style.setProperty('--ty3', ty3 + 'px');
                
                // Variáveis para tremulidade (shake) aleatória
                for (let j = 1; j <= 9; j++) {
                    const shakeX = (Math.random() - 0.5) * 3;
                    const shakeY = (Math.random() - 0.5) * 3;
                    particle.style.setProperty(`--shake-x${j}`, shakeX + 'px');
                    particle.style.setProperty(`--shake-y${j}`, shakeY + 'px');
                }
                
                // Duração e delay aleatórios
                const floatDuration = (15 + Math.random() * 10) + 's';
                const tremorDuration = (0.08 + Math.random() * 0.12) + 's';
                const animationDelay = Math.random() * 20 + 's';
                
                particle.style.setProperty('--float-duration', floatDuration);
                particle.style.setProperty('--tremor-duration', tremorDuration);
                particle.style.animationDelay = `${animationDelay}, ${Math.random() * 0.1}s`;
                
                body.appendChild(particle);
            }
        }

        createParticles(15);

        // --- Audio background logic ---
        (function() {
            const audio = document.getElementById('bg-audio');
            const muteBtn = document.getElementById('mute-btn');
            const muteLabel = document.getElementById('mute-label');
            const audioUI = document.querySelector('.audio-ui');

            let muteTimer = null;
            let muteRemaining = 0;
            let _mcc = 0;

            // Detectar se é mobile e ajustar velocidade base
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const baseRate = isMobile ? 0.5 : 0.75;
            audio.playbackRate = 0.05; // Começa muito devagar
            audio.volume = 0; // Começa em 0%
            
            // Função para atualizar volume e velocidade baseado no scroll
            function updateVolumeByScroll() {
                const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
                const scrollPercent = Math.min(Math.max(window.scrollY / scrollHeight, 0), 1); // 0 a 1
                
                // Volume de 0% a 100%
                audio.volume = scrollPercent;
                
                // Velocidade aumenta de ~0.05 até baseRate (0.5 mobile ou 0.75 desktop)
                audio.playbackRate = 0.05 + (scrollPercent * (baseRate - 0.05));
                
                // Atualizar intensidade da tremulidade do texto (0 a 1)
                const mainElement = document.querySelector('main');
                if (mainElement) {
                    mainElement.style.setProperty('--tremor-intensity', scrollPercent);
                }
                
                // Atualizar intensidade do caos das partículas (1 a 5x)
                const chaosIntensity = 1 + (scrollPercent * 4); // 1 no topo, 5 no final
                const particles = document.querySelectorAll('.particle');
                particles.forEach(particle => {
                    particle.style.setProperty('--chaos-intensity', chaosIntensity);
                });
            }

            function showUI() {
                audioUI.style.display = 'flex';
            }

            function tryPlay() {
                const p = audio.play();
                if (p && typeof p.then === 'function') {
                    p.then(() => {
                        // Atualizar volume inicial baseado na posição atual do scroll
                        updateVolumeByScroll();
                        showUI();
                    }).catch(() => {
                        // Autoplay blocked
                    });
                }
            }

            function holdMute(seconds) {
                if (muteTimer) return;
                audio.muted = true;
                muteRemaining = seconds;
                
                // Estabilizar partículas
                const particles = document.querySelectorAll('.particle.floating');
                particles.forEach(particle => {
                    particle.classList.add('stabilized');
                });
                
                muteBtn.style.display = 'none';
                muteLabel.style.display = 'block';
                muteLabel.classList.add('blink');
                updateMuteLabel();

                muteTimer = setInterval(() => {
                    muteRemaining--;
                    updateMuteLabel();
                    if (muteRemaining <= 0) {
                        clearInterval(muteTimer);
                        muteTimer = null;
                        audio.muted = false;
                        muteBtn.style.display = 'block';
                        muteLabel.style.display = 'none';
                        muteLabel.classList.remove('blink');
                        
                        // Reativar movimento das partículas
                        particles.forEach(particle => {
                            particle.classList.remove('stabilized');
                        });
                    }
                }, 1000);
            }

            function updateMuteLabel() {
                const progress = muteRemaining / 99;
                if (progress > 0.666) {
                    muteLabel.textContent = '∅';
                } else if (progress > 0.333) {
                    muteLabel.textContent = '·';
                } else {
                    muteLabel.textContent = '∅';
                }
            }

            function _dr() {
                document.body.style.transition = 'opacity 3s ease-out';
                document.body.style.opacity = '0';
                setTimeout(() => {
                    window.location.reload();
                    document.body.style.opacity = '1';
                }, 3000);
            }

            muteBtn.addEventListener('click', () => {
                _mcc++;
                if (_mcc === 4) { _dr(); return; }
                
                document.body.classList.toggle('light-theme');
                holdMute(99);
            });

            muteBtn.addEventListener('keydown', (e) => {
                if (e.key === ' ' || e.key === 'Enter') {
                    e.preventDefault();
                    muteBtn.click();
                }
            });

            audio.addEventListener('error', () => {
                audioUI.style.display = 'flex';
                muteLabel.textContent = 'sem áudio';
                muteLabel.style.display = 'block';
                muteBtn.style.display = 'none';
            });

            audio.addEventListener('play', showUI);

            audio.addEventListener('ended', () => {
                window.close();
                setTimeout(() => {
                    _dr();
                }, 100);
            });

            // Auto-scroll page based on audio time
            let isManualScroll = false;
            let scrollTimeout = null;
            
            function smoothAutoScroll() {
                if (!audio.paused && !isManualScroll && audio.duration) {
                    const duration = audio.duration;
                    const currentTime = audio.currentTime;
                    const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
                    const targetScroll = (currentTime / duration) * scrollHeight;
                    
                    window.scrollTo({
                        top: targetScroll,
                        behavior: 'smooth'
                    });
                }
                requestAnimationFrame(smoothAutoScroll);
            }
            
            smoothAutoScroll();

            // Manual scroll controls audio position and volume
            let lastScrollY = window.scrollY;
            let hasScrolled = false;
            
            window.addEventListener('scroll', () => {
                const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
                const scrollPercent = window.scrollY / scrollHeight;
                
                // Atualizar volume baseado no scroll
                updateVolumeByScroll();
                
                // Se o usuário scrollar e o áudio ainda não iniciou, iniciar
                if (!hasScrolled && Math.abs(window.scrollY - lastScrollY) > 10) {
                    hasScrolled = true;
                    if (audio.paused) {
                        tryPlay();
                    }
                }
                
                if (Math.abs(window.scrollY - lastScrollY) > 5) {
                    isManualScroll = true;
                    clearTimeout(scrollTimeout);
                    
                    if (!audio.paused && audio.duration) {
                        const newTime = scrollPercent * audio.duration;
                        audio.currentTime = newTime;
                    }
                    
                    scrollTimeout = setTimeout(() => {
                        isManualScroll = false;
                    }, 2000);
                }
                
                lastScrollY = window.scrollY;
            }, { passive: true });

            // Auto-play after 99 seconds from page load
            setTimeout(() => {
                tryPlay();
            }, 99000);

            // If user interacts anywhere, attempt to play once
            function onFirstInteraction() {
                if (audio.paused) {
                    tryPlay();
                }
            }

            window.addEventListener('pointerdown', onFirstInteraction, { once: true });
            window.addEventListener('keydown', onFirstInteraction, { once: true });
        })();
    </script>
</body>
</html>
